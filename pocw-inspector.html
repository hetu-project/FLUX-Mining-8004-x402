<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoCW Blockchain Inspector</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1a1a1a; color: #00ff00; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #333; background: #222; }
        .btn { padding: 8px 16px; background: #333; color: #00ff00; border: 1px solid #555; cursor: pointer; margin: 5px; }
        .btn:hover { background: #444; }
        input, select { padding: 8px; background: #333; color: #00ff00; border: 1px solid #555; margin: 5px; }
        .output { background: #111; padding: 15px; border: 1px solid #333; margin: 10px 0; max-height: 400px; overflow-y: auto; }
        .highlight { color: #ffff00; }
        .error { color: #ff0000; }
        .success { color: #00ff00; }
        h1, h2 { color: #00ffff; }
        .tx-hash { color: #ff6b6b; word-break: break-all; }
        .address { color: #4ecdc4; word-break: break-all; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç PoCW Blockchain Inspector</h1>
        
        <div class="section">
            <h2>Network Status</h2>
            <button class="btn" onclick="checkNetwork()">Check Network</button>
            <button class="btn" onclick="getLatestBlock()">Get Latest Block</button>
            <div id="network-status" class="output">Click "Check Network" to see status...</div>
        </div>

        <div class="section">
            <h2>Block Inspector</h2>
            <input type="number" id="blockNumber" placeholder="Block number (or leave empty for latest)" style="width: 200px;">
            <button class="btn" onclick="getBlock()">Get Block Details</button>
            <div id="block-output" class="output">Enter block number and click "Get Block Details"...</div>
        </div>

        <div class="section">
            <h2>Transaction Inspector</h2>
            <input type="text" id="txHash" placeholder="Transaction hash" style="width: 500px;">
            <button class="btn" onclick="getTransaction()">Get Transaction</button>
            <div id="tx-output" class="output">Enter transaction hash and click "Get Transaction"...</div>
        </div>

        <div class="section">
            <h2>Contract Inspector</h2>
            <select id="contractSelect">
                <option value="identity">ERC-8004 Identity Registry</option>
                <option value="hetu">HETU Token</option>
                <option value="flux">Intelligence Token (FLUX)</option>
                <option value="aiusd">AIUSD Token (x402 Payment)</option>
                <option value="escrow">x402 Payment Escrow</option>
                <option value="subnet">Subnet Registry</option>
                <option value="verifier">PoCW Verifier</option>
            </select>
            <button class="btn" onclick="getContractInfo()">Get Contract Info</button>
            <div id="contract-output" class="output">Select contract and click "Get Contract Info"...</div>
        </div>

        <div class="section">
            <h2>üÜî ERC-8004 Identity Registry</h2>
            <button class="btn" onclick="getAgentIdentities()">View All Agent IDs</button>
            <input type="text" id="checkOwnerAddress" placeholder="Check agent IDs for address" style="width: 400px;">
            <button class="btn" onclick="checkAgentIDs()">Check Address</button>
            <div id="identity-output" class="output">Click "View All Agent IDs" to see registered agents...</div>
        </div>

        <div class="section">
            <h2>Account Inspector</h2>
            <input type="text" id="accountAddress" placeholder="Enter address (miner, validator, etc.)" style="width: 400px;">
            <button class="btn" onclick="getAccountInfo()">Get Account Info</button>
            <div id="account-output" class="output">Enter address and click "Get Account Info"...</div>
        </div>

        <div class="section">
            <h2>Transaction Decoder</h2>
            <input type="text" id="decodeTxHash" placeholder="Transaction hash to decode" style="width: 500px;">
            <button class="btn" onclick="decodeTransaction()">Decode Transaction</button>
            <div id="decode-output" class="output">Enter transaction hash to decode contract calls...</div>
        </div>

        <div class="section">
            <h2>Recent Transactions</h2>
            <button class="btn" onclick="getRecentTransactions()">Get Last 10 Transactions</button>
            <div id="recent-tx-output" class="output">Click "Get Last 10 Transactions"...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/dist/ethers.umd.min.js"></script>
    <script>
        console.log("üîç PoCW Inspector loading...");
        
        let provider;
        let contractAddresses = {
            "IdentityRegistry": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
            "HETUToken": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
            "FLUXToken": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
            "AIUSDToken": "",  // Will be loaded from contract_addresses.json
            "x402PaymentEscrow": "",  // Will be loaded from contract_addresses.json
            "SubnetRegistry": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
            "PoCWVerifier": "0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9"
        };

        const contractABIsByType = {
            "IdentityRegistry": [
                "function balanceOf(address) view returns (uint256)",
                "function ownerOf(uint256) view returns (address)",
                "function tokenOfOwnerByIndex(address, uint256) view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)",
                "function totalSupply() view returns (uint256)"
            ],
            "HETUToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)"
            ],
            "FLUXToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)"
            ],
            "AIUSDToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)",
                "function decimals() view returns (uint8)"
            ],
            "x402PaymentEscrow": [
                "function getPayment(string) view returns (tuple(address,address,uint256,uint8,uint256,uint256))",
                "function coordinator() view returns (address)",
                "function aiusdToken() view returns (address)"
            ],
            "PoCWVerifier": [
                "function getReputationScores(address) view returns (uint256, uint256)",
                "function calculateReputationScore(address) view returns (uint256)",
                "function calculateValidatorReputationScore(address) view returns (uint256)",
                "function minerIds(address) view returns (address, uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool, bytes32)",
                "function getValidatorStats(address) view returns (tuple(uint256,uint256,uint256,uint256,bool,uint256,uint256,uint256))",
                "function getValidatorConfidenceScore(address) view returns (uint256)",
                "function getEpochSubmission(bytes32, uint256) view returns (tuple(uint256,bytes,address[],uint256,bool,bool,uint256))",
                "function getSubnet(bytes32) view returns (tuple(address[],uint256,bool,uint256,uint256))",
                "function verifyAndDistributeRewards(bytes32, uint256, bool) returns (bool)",
                "function submitAndDistributeEpoch(string memory subnetId, bytes memory vlcGraphData, address[] memory successfulMiners, uint256 successfulTasks, uint256 failedTasks) external"
            ]
        };

        let contractABIs = {};

        function updateContractABIs() {
            contractABIs = {};
            for (const [type, address] of Object.entries(contractAddresses)) {
                if (contractABIsByType[type]) {
                    contractABIs[address] = contractABIsByType[type];
                }
            }
        }

        async function loadContractAddresses() {
            try {
                console.log("üîÑ Loading contract addresses...");
                const response = await fetch('./contract_addresses.json');
                if (response.ok) {
                    const addresses = await response.json();
                    console.log("üìÑ Loaded addresses:", addresses);

                    // Load from new format where keys are contract names
                    if (addresses.AIUSD) {
                        contractAddresses.AIUSDToken = addresses.AIUSD;
                        contractAddresses.x402PaymentEscrow = addresses.x402PaymentEscrow;
                        contractAddresses.IdentityRegistry = addresses.IdentityRegistry || contractAddresses.IdentityRegistry;
                        contractAddresses.HETUToken = addresses.HETUToken || contractAddresses.HETUToken;
                        contractAddresses.FLUXToken = addresses.FLUXToken || contractAddresses.FLUXToken;
                        contractAddresses.SubnetRegistry = addresses.SubnetRegistry || contractAddresses.SubnetRegistry;
                        contractAddresses.PoCWVerifier = addresses.PoCWVerifier || contractAddresses.PoCWVerifier;
                    } else {
                        // Fallback to old format (address -> name mapping)
                        for (const [address, name] of Object.entries(addresses)) {
                            if (name === "ERC-8004 Identity Registry") contractAddresses.IdentityRegistry = address;
                            else if (name === "HETU Token") contractAddresses.HETUToken = address;
                            else if (name === "Intelligence Token (FLUX)") contractAddresses.FLUXToken = address;
                            else if (name.includes("Subnet Registry")) contractAddresses.SubnetRegistry = address;
                            else if (name.includes("PoCW") && name.includes("Verifier")) contractAddresses.PoCWVerifier = address;
                        }
                    }
                    updateContractABIs();
                    console.log("‚úÖ Updated contract addresses:", contractAddresses);
                }
            } catch (error) {
                console.log("‚ö†Ô∏è Using fallback addresses:", error.message);
            }
            updateContractABIs();
        }

        function waitForEthers() {
            if (typeof ethers !== 'undefined') {
                console.log("‚úÖ Ethers loaded");
                initializeApp();
            } else {
                console.log("‚è≥ Waiting for ethers...");
                setTimeout(waitForEthers, 100);
            }
        }
        
        async function initializeApp() {
            console.log("üöÄ Initializing app...");
            try {
                provider = new ethers.JsonRpcProvider("http://localhost:8545");
                console.log("‚úÖ Provider created");
                await loadContractAddresses();
                console.log("‚úÖ App initialized successfully");
            } catch (error) {
                console.error("‚ùå Init error:", error);
            }
        }

        async function checkNetwork() {
            try {
                console.log("üîç Checking network...");
                document.getElementById('network-status').innerHTML = `<div class="highlight">üîç Checking network...</div>`;
                
                const network = await provider.getNetwork();
                const blockNumber = await provider.getBlockNumber();
                const balance = await provider.getBalance("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
                
                let networkName = network.name;
                if (network.chainId === 31337n || network.chainId === 1337n) {
                    networkName = "Anvil/Hardhat Local";
                }
                
                document.getElementById('network-status').innerHTML = `
                    <div class="success">‚úÖ Connected to ${networkName}</div>
                    <div><span class="highlight">Chain ID:</span> ${network.chainId}</div>
                    <div><span class="highlight">Latest Block:</span> ${blockNumber}</div>
                    <div><span class="highlight">Deployer Balance:</span> ${ethers.formatEther(balance)} ETH</div>
                    <div><span class="highlight">RPC URL:</span> http://localhost:8545</div>
                `;
            } catch (error) {
                console.error("‚ùå Network check failed:", error);
                document.getElementById('network-status').innerHTML = `
                    <div class="error">‚ùå Connection Failed: ${error.message}</div>
                    <div style="margin-top: 10px;">
                        <span class="highlight">Troubleshooting:</span><br>
                        ‚Ä¢ Make sure Anvil is running on http://localhost:8545<br>
                        ‚Ä¢ Check console for detailed error messages
                    </div>
                `;
            }
        }

        async function getLatestBlock() {
            try {
                const blockNumber = await provider.getBlockNumber();
                const block = await provider.getBlock(blockNumber);
                
                document.getElementById('network-status').innerHTML = `
                    <div class="success">üìÑ Latest Block Details</div>
                    <div><span class="highlight">Number:</span> ${block.number}</div>
                    <div><span class="highlight">Hash:</span> ${block.hash}</div>
                    <div><span class="highlight">Transactions:</span> ${block.transactions.length}</div>
                    <div><span class="highlight">Timestamp:</span> ${new Date(block.timestamp * 1000).toLocaleString()}</div>
                `;
            } catch (error) {
                document.getElementById('network-status').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getBlock() {
            try {
                const blockNumberInput = document.getElementById('blockNumber').value.trim();
                const blockNumber = blockNumberInput ? parseInt(blockNumberInput) : await provider.getBlockNumber();
                
                document.getElementById('block-output').innerHTML = '<div class="highlight">üîç Loading block...</div>';
                
                const block = await provider.getBlock(blockNumber);
                if (!block) {
                    document.getElementById('block-output').innerHTML = '<div class="error">‚ùå Block not found</div>';
                    return;
                }
                
                const output = `
                    <div class="success">üìÑ Block ${block.number} Details</div>
                    <div><span class="highlight">Hash:</span> ${block.hash}</div>
                    <div><span class="highlight">Parent Hash:</span> ${block.parentHash}</div>
                    <div><span class="highlight">Timestamp:</span> ${new Date(block.timestamp * 1000).toLocaleString()}</div>
                    <div><span class="highlight">Gas Used:</span> ${block.gasUsed.toString()}</div>
                    <div><span class="highlight">Gas Limit:</span> ${block.gasLimit.toString()}</div>
                    <div><span class="highlight">Transactions:</span> ${block.transactions.length}</div>
                    ${block.transactions.length > 0 ? `<div><span class="highlight">Transaction Hashes:</span><br>${block.transactions.map(tx => `<span class="tx-hash">${tx}</span>`).join('<br>')}</div>` : ''}
                `;
                
                document.getElementById('block-output').innerHTML = output;
            } catch (error) {
                document.getElementById('block-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getTransaction() {
            try {
                const txHash = document.getElementById('txHash').value.trim();
                if (!txHash) {
                    document.getElementById('tx-output').innerHTML = '<div class="error">‚ùå Please enter transaction hash</div>';
                    return;
                }
                
                document.getElementById('tx-output').innerHTML = '<div class="highlight">üîç Loading transaction...</div>';
                
                const tx = await provider.getTransaction(txHash);
                const receipt = await provider.getTransactionReceipt(txHash);
                
                if (!tx) {
                    document.getElementById('tx-output').innerHTML = '<div class="error">‚ùå Transaction not found</div>';
                    return;
                }
                
                const output = `
                    <div class="success">üìÑ Transaction Details</div>
                    <div><span class="highlight">Hash:</span> <span class="tx-hash">${tx.hash}</span></div>
                    <div><span class="highlight">From:</span> <span class="address">${tx.from}</span></div>
                    <div><span class="highlight">To:</span> <span class="address">${tx.to || 'Contract Creation'}</span></div>
                    <div><span class="highlight">Value:</span> ${ethers.formatEther(tx.value)} ETH</div>
                    <div><span class="highlight">Gas Price:</span> ${tx.gasPrice ? ethers.formatUnits(tx.gasPrice, "gwei") + " gwei" : 'N/A'}</div>
                    <div><span class="highlight">Gas Limit:</span> ${tx.gasLimit.toString()}</div>
                    <div><span class="highlight">Nonce:</span> ${tx.nonce}</div>
                    <div><span class="highlight">Block:</span> ${tx.blockNumber || 'Pending'}</div>
                    <div><span class="highlight">Status:</span> ${receipt ? (receipt.status === 1 ? '<span class="success">Success</span>' : '<span class="error">Failed</span>') : 'Pending'}</div>
                    ${receipt ? `<div><span class="highlight">Gas Used:</span> ${receipt.gasUsed.toString()}</div>` : ''}
                `;
                
                document.getElementById('tx-output').innerHTML = output;
            } catch (error) {
                document.getElementById('tx-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getContractInfo() {
            try {
                const selected = document.getElementById('contractSelect').value;

                // Map dropdown values to addresses
                const addressMap = {
                    'identity': contractAddresses.IdentityRegistry,
                    'hetu': contractAddresses.HETUToken,
                    'flux': contractAddresses.FLUXToken,
                    'aiusd': contractAddresses.AIUSDToken,
                    'escrow': contractAddresses.x402PaymentEscrow,
                    'subnet': contractAddresses.SubnetRegistry,
                    'verifier': contractAddresses.PoCWVerifier
                };

                const address = addressMap[selected];
                if (!address || address === '') {
                    document.getElementById('contract-output').innerHTML = `
                        <div class="error">‚ùå Contract address not found</div>
                        <div style="margin-top: 10px;">
                            <span class="highlight">Selected:</span> ${selected}<br>
                            <span class="highlight">Address value:</span> ${address || 'undefined'}<br>
                            <span class="highlight">Tip:</span> Make sure the deployment script has completed and contract_addresses.json is updated
                        </div>
                    `;
                    console.log('Contract addresses:', contractAddresses);
                    return;
                }

                document.getElementById('contract-output').innerHTML = '<div class="highlight">üîç Loading contract info...</div>';

                const code = await provider.getCode(address);
                const balance = await provider.getBalance(address);

                let output = `
                    <div class="success">üìÑ Contract: ${selected.toUpperCase()}</div>
                    <div><span class="highlight">Address:</span> <span class="address">${address}</span></div>
                    <div><span class="highlight">Balance:</span> ${ethers.formatEther(balance)} ETH</div>
                    <div><span class="highlight">Is Contract:</span> ${code !== '0x' ? '<span class="success">Yes</span>' : '<span class="error">No</span>'}</div>
                `;

                // Add contract-specific info if available
                const typeMap = {
                    'identity': 'IdentityRegistry',
                    'hetu': 'HETUToken',
                    'flux': 'FLUXToken',
                    'aiusd': 'AIUSDToken',
                    'escrow': 'x402PaymentEscrow',
                    'verifier': 'PoCWVerifier'
                };

                const contractType = typeMap[selected];
                if (contractType && contractABIsByType[contractType]) {
                    const contract = new ethers.Contract(address, contractABIsByType[contractType], provider);

                    try {
                        if (selected === 'identity' || selected === 'hetu' || selected === 'flux' || selected === 'aiusd') {
                            const name = await contract.name();
                            const symbol = await contract.symbol();
                            const totalSupply = await contract.totalSupply();
                            output += `
                                <div style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                                    <div><span class="highlight">Name:</span> ${name}</div>
                                    <div><span class="highlight">Symbol:</span> ${symbol}</div>
                                    <div><span class="highlight">Total Supply:</span> ${ethers.formatEther(totalSupply)}</div>
                                </div>
                            `;
                        } else if (selected === 'escrow') {
                            const coordinatorAddr = await contract.coordinator();
                            const aiusdAddr = await contract.aiusdToken();
                            output += `
                                <div style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                                    <div><span class="highlight">Coordinator:</span> <span class="address">${coordinatorAddr}</span></div>
                                    <div><span class="highlight">AIUSD Token:</span> <span class="address">${aiusdAddr}</span></div>
                                </div>
                            `;
                        }
                    } catch (e) {
                        console.log("Could not get contract details:", e.message);
                    }
                }

                document.getElementById('contract-output').innerHTML = output;
            } catch (error) {
                document.getElementById('contract-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getAccountInfo() {
            try {
                const address = document.getElementById('accountAddress').value.trim();
                if (!address) {
                    document.getElementById('account-output').innerHTML = '<div class="error">‚ùå Please enter an address</div>';
                    return;
                }

                document.getElementById('account-output').innerHTML = '<div class="highlight">üîç Loading account...</div>';

                const ethBalance = await provider.getBalance(address);
                const transactionCount = await provider.getTransactionCount(address);
                const code = await provider.getCode(address);
                const isContract = code !== '0x';

                let output = `
                    <div class="success">üë§ Account: ${address}</div>
                    <div><span class="highlight">ETH Balance:</span> ${ethers.formatEther(ethBalance)} ETH</div>
                    <div><span class="highlight">Nonce:</span> ${transactionCount}</div>
                    <div><span class="highlight">Type:</span> ${isContract ? '<span class="highlight">Contract</span>' : 'EOA (Externally Owned Account)'}</div>
                `;

                // Known address roles
                const knownAddresses = {
                    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266": "üîß Deployer", 
                    "0x70997970C51812dc3A010C7d01b50e0d17dc79C8": "‚úÖ Validator 1", 
                    "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC": "‚úÖ Validator 2",
                    "0x90F79bf6EB2c4f870365E785982E1f101E93b906": "‚úÖ Validator 3",
                    "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65": "‚úÖ Validator 4",
                    "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc": "‚õèÔ∏è Miner 1"
                };

                if (knownAddresses[address]) {
                    output += `<div style="margin-top: 10px;"><span class="highlight">Role:</span> ${knownAddresses[address]}</div>`;
                }

                // Try to get token balances
                try {
                    const hetuAddr = contractAddresses.HETUToken;
                    const hetuInterface = new ethers.Interface(contractABIs[hetuAddr]);
                    const hetuContract = new ethers.Contract(hetuAddr, hetuInterface, provider);
                    const hetuBalance = await hetuContract.balanceOf(address);

                    const fluxAddr = contractAddresses.FLUXToken;
                    const fluxInterface = new ethers.Interface(contractABIs[fluxAddr]);
                    const fluxContract = new ethers.Contract(fluxAddr, fluxInterface, provider);
                    const fluxBalance = await fluxContract.balanceOf(address);

                    output += `
                        <div style="margin-top: 15px;"><span class="highlight">Token Balances:</span></div>
                        <div style="margin-left: 20px;"><span class="highlight">HETU:</span> ${ethers.formatEther(hetuBalance)} HETU</div>
                        <div style="margin-left: 20px;"><span class="highlight">FLUX:</span> ${ethers.formatEther(fluxBalance)} FLUX</div>
                    `;

                    // Add AIUSD balance if contract is loaded
                    if (contractAddresses.AIUSDToken && contractAddresses.AIUSDToken !== '') {
                        try {
                            const aiusdAddr = contractAddresses.AIUSDToken;
                            const aiusdInterface = new ethers.Interface(contractABIs[aiusdAddr]);
                            const aiusdContract = new ethers.Contract(aiusdAddr, aiusdInterface, provider);
                            const aiusdBalance = await aiusdContract.balanceOf(address);
                            output += `<div style="margin-left: 20px;"><span class="highlight">AIUSD:</span> ${ethers.formatEther(aiusdBalance)} AIUSD</div>`;
                        } catch (aiusdError) {
                            console.log("‚ö†Ô∏è Could not get AIUSD balance:", aiusdError.message);
                        }
                    }

                    // Get reputation scores from PoCW contract
                    try {
                        const pocwAddr = contractAddresses.PoCWVerifier;
                        const pocwInterface = new ethers.Interface(contractABIs[pocwAddr]);
                        const pocwContract = new ethers.Contract(pocwAddr, pocwInterface, provider);
                        
                        let minerRep = 0, validatorRep = 0;
                        
                        try {
                            const result = await pocwContract.getReputationScores(address);
                            minerRep = result[0];
                            validatorRep = result[1];
                        } catch (repError) {
                            try {
                                minerRep = await pocwContract.calculateReputationScore(address);
                            } catch (e) { minerRep = 0; }
                            try {
                                validatorRep = await pocwContract.calculateValidatorReputationScore(address);
                            } catch (e) { validatorRep = 0; }
                        }
                        
                        if (Number(minerRep) > 0 && Number(validatorRep) > 0) {
                            output += `
                                <div style="margin-top: 15px;"><span class="highlight">Reputation Scores:</span></div>
                                <div style="margin-left: 20px;"><span class="highlight">Miner Reputation:</span> ${minerRep.toString()} points</div>
                                <div style="margin-left: 20px;"><span class="highlight">Validator Reputation:</span> ${validatorRep.toString()} points</div>
                            `;
                        } else if (Number(minerRep) > 0) {
                            output += `<div style="margin-top: 15px;"><span class="highlight">Miner Reputation:</span> ${minerRep.toString()} points</div>`;
                        } else if (Number(validatorRep) > 0) {
                            output += `<div style="margin-top: 15px;"><span class="highlight">Validator Reputation:</span> ${validatorRep.toString()} points</div>`;
                        }
                    } catch (repError) {
                        console.log("‚ö†Ô∏è Could not get reputation scores:", repError.message);
                    }
                } catch (tokenError) {
                    console.log("‚ö†Ô∏è Could not get token balances:", tokenError.message);
                }

                document.getElementById('account-output').innerHTML = output;
            } catch (error) {
                document.getElementById('account-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getRecentTransactions() {
            try {
                document.getElementById('recent-tx-output').innerHTML = '<div class="highlight">üîç Loading transactions...</div>';
                
                const latestBlock = await provider.getBlockNumber();
                const transactions = [];
                
                for (let i = Math.max(0, latestBlock - 10); i <= latestBlock; i++) {
                    const block = await provider.getBlock(i);
                    if (block && block.transactions.length > 0) {
                        for (const txHash of block.transactions) {
                            const tx = await provider.getTransaction(txHash);
                            transactions.push({...tx, blockNumber: i});
                        }
                    }
                }
                
                const output = transactions.length > 0 ? `
                    <div class="success">üìÑ Recent Transactions (${transactions.length})</div>
                    ${transactions.slice(-10).reverse().map(tx => `
                        <div style="margin: 10px 0; padding: 10px; border: 1px solid #333; background: #111;">
                            <div><span class="highlight">Block ${tx.blockNumber}:</span> <span class="tx-hash">${tx.hash}</span></div>
                            <div><span class="highlight">From:</span> <span class="address">${tx.from}</span></div>
                            <div><span class="highlight">To:</span> <span class="address">${tx.to || 'Contract Creation'}</span></div>
                            <div><span class="highlight">Value:</span> ${ethers.formatEther(tx.value)} ETH</div>
                        </div>
                    `).join('')}
                ` : '<div class="error">No recent transactions found</div>';
                
                document.getElementById('recent-tx-output').innerHTML = output;
            } catch (error) {
                document.getElementById('recent-tx-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function decodeTransaction() {
            try {
                const txHash = document.getElementById('decodeTxHash').value.trim();
                if (!txHash) {
                    document.getElementById('decode-output').innerHTML = '<div class="error">‚ùå Please enter transaction hash</div>';
                    return;
                }
                
                console.log("üîç Decoding transaction:", txHash);
                document.getElementById('decode-output').innerHTML = '<div class="highlight">üîç Loading transaction...</div>';
                
                const tx = await provider.getTransaction(txHash);
                const receipt = await provider.getTransactionReceipt(txHash);
                
                if (!tx) {
                    document.getElementById('decode-output').innerHTML = '<div class="error">‚ùå Transaction not found</div>';
                    return;
                }
                
                let output = `
                    <div class="success">üîç Transaction Decoder</div>
                    <div><span class="highlight">Hash:</span> <span class="tx-hash">${tx.hash}</span></div>
                    <div><span class="highlight">To Contract:</span> <span class="address">${tx.to}</span></div>
                    <div><span class="highlight">Status:</span> ${receipt.status === 1 ? '<span class="success">Success</span>' : '<span class="error">Failed</span>'}</div>
                `;

                // Decode function call if we have the ABI
                console.log("üîç Transaction decoding debug:");
                console.log("  - tx.data:", tx.data);
                console.log("  - tx.to:", tx.to);
                console.log("  - Has tx.data:", !!(tx.data && tx.data !== '0x'));
                console.log("  - Has ABI for contract:", !!contractABIs[tx.to]);
                console.log("  - Available contractABIs keys:", Object.keys(contractABIs));
                
                if (tx.data && tx.data !== '0x') {
                    const functionSelector = tx.data.slice(0, 10);
                    console.log("  - Function selector:", functionSelector);
                    
                    if (contractABIs[tx.to]) {
                        console.log("  - ABI for contract:", contractABIs[tx.to]);
                        
                        try {
                            const contractInterface = new ethers.Interface(contractABIs[tx.to]);
                            console.log("  - Contract interface created successfully");
                            const decoded = contractInterface.parseTransaction({ data: tx.data, value: tx.value });
                            console.log("  - Transaction decoded successfully:", decoded);
                        
                            output += `
                                <div style="margin-top: 15px;"><span class="highlight">Function Call:</span></div>
                                <div style="margin-left: 20px;"><span class="highlight">Function:</span> ${decoded.name}</div>
                            `;
                        
                            if (decoded.args && decoded.args.length > 0) {
                                output += `<div style="margin-left: 20px;"><span class="highlight">Parameters:</span></div>`;
                                decoded.args.forEach((arg, idx) => {
                                    const param = decoded.fragment.inputs[idx];
                                    let value = arg.toString();
                                    
                                    // Format specific types
                                    if (param.type === 'uint256' && value.length > 10) {
                                        value = `${ethers.formatEther(arg)} (${value} wei)`;
                                    } else if (param.type === 'bytes32') {
                                        value = `${arg} (32-byte hash)`;
                                    } else if (param.type === 'bytes' && value.startsWith('0x')) {
                                        try {
                                            const decoded_bytes = ethers.toUtf8String(arg);
                                            if (decoded_bytes.includes('{') && decoded_bytes.includes('}')) {
                                                try {
                                                    const jsonData = JSON.parse(decoded_bytes);
                                                    value = `<div style="background: #0a0a0a; padding: 10px; margin: 5px 0; border: 1px solid #333;">
                                                        <div style="color: #ffff00;">üìä VLC Graph Data:</div>
                                                        <pre style="color: #00ff00; font-size: 11px; margin: 5px 0; white-space: pre-wrap;">${JSON.stringify(jsonData, null, 2)}</pre>
                                                    </div>`;
                                                } catch (jsonError) {
                                                    value = `Text data: "${decoded_bytes}"`;
                                                }
                                            } else {
                                                value = `Text: "${decoded_bytes.replace(/\0/g, '')}"`;
                                            }
                                        } catch (e) {
                                            value = `Binary data (${(value.length - 2) / 2} bytes): ${value.substring(0, 50)}${value.length > 50 ? '...' : ''}`;
                                        }
                                    } else if (param.type.includes('address')) {
                                        if (Array.isArray(arg)) {
                                            value = arg.map(addr => `<span class="address">${addr}</span>`).join(', ');
                                        } else {
                                            value = `<span class="address">${arg}</span>`;
                                        }
                                    } else if (param.type === 'string') {
                                        value = `"${arg}"`;
                                    } else if (param.type.includes('[]')) {
                                        if (Array.isArray(arg)) {
                                            value = `[${arg.join(', ')}] (${arg.length} items)`;
                                        } else {
                                            value = arg.toString();
                                        }
                                    } else if (param.type === 'bool') {
                                        value = arg ? '‚úÖ true' : '‚ùå false';
                                    }
                                    
                                    output += `<div style="margin-left: 40px;">${param.name} (${param.type}): ${value}</div>`;
                                });
                            }
                        } catch (e) {
                            console.log("‚ùå Failed to decode transaction:", e);
                            console.log("  - Error message:", e.message);
                            output += `<div style="margin-top: 10px;"><span class="error">Could not decode function call: ${e.message}</span></div>`;
                            output += `<div style="margin-top: 10px;"><span class="highlight">Raw Data:</span> ${tx.data}</div>`;
                        }
                    } else {
                        console.log("‚ö†Ô∏è Cannot decode transaction:");
                        if (!tx.data || tx.data === '0x') {
                            console.log("  - No transaction data");
                        } else if (!contractABIs[tx.to]) {
                            console.log("  - No ABI available for contract:", tx.to);
                        }
                    }
                    
                    if (tx.data && tx.data !== '0x') {
                        output += `<div style="margin-top: 10px;"><span class="highlight">Raw Input Data:</span><br><div style="word-break: break-all; font-size: 10px; background: #0a0a0a; padding: 10px;">${tx.data}</div></div>`;
                    }
                }

                // Decode events
                if (receipt.logs && receipt.logs.length > 0) {
                    output += `<div style="margin-top: 15px;"><span class="highlight">Events Emitted (${receipt.logs.length}):</span></div>`;
                    
                    receipt.logs.forEach((log, idx) => {
                        if (contractABIs[log.address]) {
                            try {
                                const contractInterface = new ethers.Interface(contractABIs[log.address]);
                                const parsedLog = contractInterface.parseLog(log);
                                
                                output += `
                                    <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                        <div><span class="highlight">Event:</span> ${parsedLog.name}</div>
                                        <div><span class="highlight">Contract:</span> <span class="address">${log.address}</span></div>
                                `;
                                
                                if (parsedLog.args && parsedLog.args.length > 0) {
                                    parsedLog.args.forEach((arg, argIdx) => {
                                        const input = parsedLog.fragment.inputs[argIdx];
                                        let value = arg.toString();
                                        
                                        if (input.type === 'uint256' && value.length > 10) {
                                            value = `${ethers.formatEther(arg)} tokens`;
                                        } else if (input.type.includes('address')) {
                                            value = `<span class="address">${arg}</span>`;
                                        }
                                        
                                        output += `<div style="margin-left: 20px;">${input.name}: ${value}</div>`;
                                    });
                                }
                                output += `</div>`;
                            } catch (e) {
                                output += `
                                    <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                        <div>Event ${idx}: <span class="address">${log.address}</span></div>
                                        <div>Topics: ${log.topics.length}</div>
                                    </div>
                                `;
                            }
                        } else {
                            output += `
                                <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                    <div>Event ${idx}: <span class="address">${log.address}</span></div>
                                    <div>Topics: ${log.topics.length}</div>
                                </div>
                            `;
                        }
                    });
                }

                document.getElementById('decode-output').innerHTML = output;
            } catch (error) {
                console.error("‚ùå Decode error:", error);
                document.getElementById('decode-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // ERC-8004 Identity Registry Functions
        async function getAgentIdentities() {
            try {
                document.getElementById('identity-output').innerHTML = `<div class="highlight">üîç Loading agent identities...</div>`;

                const identityAddress = contractAddresses.IdentityRegistry;
                const identityABI = contractABIsByType.IdentityRegistry;
                const identity = new ethers.Contract(identityAddress, identityABI, provider);

                // Get total supply of identity tokens
                let totalSupply;
                try {
                    totalSupply = await identity.totalSupply();
                } catch {
                    totalSupply = 0n;
                }

                let output = `
                    <div><span class="highlight">Identity Registry:</span> <span class="address">${identityAddress}</span></div>
                    <div><span class="highlight">Total Agent IDs:</span> ${totalSupply.toString()}</div>
                    <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
                        <div class="highlight">üìã Registered Agents:</div>
                `;

                // Try to get all agent IDs (assuming they start from 0)
                const knownAddresses = [
                    {name: "Deployer", addr: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"},
                    {name: "Validator-1", addr: "0x70997970C51812dc3A010C7d01b50e0d17dc79C8"},
                    {name: "Validator-2", addr: "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC"},
                    {name: "Validator-3", addr: "0x90F79bf6EB2c4f870365E785982E1f101E93b906"},
                    {name: "Validator-4", addr: "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65"},
                    {name: "Miner", addr: "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc"}
                ];

                // Check all known addresses for agent IDs
                for (const {name, addr} of knownAddresses) {
                    try {
                        const balance = await identity.balanceOf(addr);
                        if (balance > 0n) {
                            output += `<div style="margin: 10px 0; padding: 10px; background: #111; border-left: 3px solid #00ff00;">`;
                            output += `<div><span class="success">üë§ ${name}</span></div>`;
                            output += `<div><span class="highlight">Address:</span> <span class="address">${addr}</span></div>`;
                            output += `<div><span class="highlight">Agent IDs owned:</span> ${balance.toString()}</div>`;

                            // Get all agent IDs for this owner
                            for (let i = 0; i < Number(balance); i++) {
                                try {
                                    const tokenId = await identity.tokenOfOwnerByIndex(addr, i);
                                    output += `<div style="margin-left: 20px;"><span class="highlight">Agent ID ${i}:</span> ${tokenId.toString()}</div>`;
                                } catch {}
                            }
                            output += `</div>`;
                        }
                    } catch {}
                }

                output += `</div>`;
                document.getElementById('identity-output').innerHTML = output;

            } catch (error) {
                console.error("‚ùå Identity load error:", error);
                document.getElementById('identity-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function checkAgentIDs() {
            try {
                const address = document.getElementById('checkOwnerAddress').value.trim();
                if (!address) {
                    document.getElementById('identity-output').innerHTML = `<div class="error">‚ùå Please enter an address</div>`;
                    return;
                }

                document.getElementById('identity-output').innerHTML = `<div class="highlight">üîç Checking agent IDs for ${address}...</div>`;

                const identityAddress = contractAddresses.IdentityRegistry;
                const identityABI = contractABIsByType.IdentityRegistry;
                const identity = new ethers.Contract(identityAddress, identityABI, provider);

                const balance = await identity.balanceOf(address);

                let output = `
                    <div><span class="highlight">Address:</span> <span class="address">${address}</span></div>
                    <div><span class="highlight">Agent IDs owned:</span> ${balance.toString()}</div>
                `;

                if (balance > 0n) {
                    output += `<div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">`;
                    output += `<div class="highlight">Agent IDs:</div>`;

                    for (let i = 0; i < Number(balance); i++) {
                        try {
                            const tokenId = await identity.tokenOfOwnerByIndex(address, i);
                            output += `
                                <div style="margin: 5px 0; padding: 8px; background: #111;">
                                    <span class="highlight">Agent ID ${i}:</span> <span class="success">${tokenId.toString()}</span>
                                </div>
                            `;
                        } catch (error) {
                            output += `<div class="error">Error getting token ${i}: ${error.message}</div>`;
                        }
                    }
                    output += `</div>`;
                } else {
                    output += `<div class="error" style="margin-top: 10px;">‚ùå No agent IDs found for this address</div>`;
                }

                document.getElementById('identity-output').innerHTML = output;

            } catch (error) {
                console.error("‚ùå Check error:", error);
                document.getElementById('identity-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // Start waiting for ethers
        waitForEthers();
    </script>
</body>
</html>