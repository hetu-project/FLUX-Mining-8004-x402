<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoCW Blockchain Inspector</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1a1a1a; color: #00ff00; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #333; background: #222; }
        .btn { padding: 8px 16px; background: #333; color: #00ff00; border: 1px solid #555; cursor: pointer; margin: 5px; }
        .btn:hover { background: #444; }
        input, select { padding: 8px; background: #333; color: #00ff00; border: 1px solid #555; margin: 5px; }
        .output { background: #111; padding: 15px; border: 1px solid #333; margin: 10px 0; max-height: 400px; overflow-y: auto; }
        .highlight { color: #ffff00; }
        .error { color: #ff0000; }
        .success { color: #00ff00; }
        h1, h2 { color: #00ffff; }
        .tx-hash { color: #ff6b6b; word-break: break-all; }
        .address { color: #4ecdc4; word-break: break-all; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç PoCW Blockchain Inspector</h1>
        
        <div class="section">
            <h2>Network Status</h2>
            <button class="btn" onclick="checkNetwork()">Check Network</button>
            <button class="btn" onclick="getLatestBlock()">Get Latest Block</button>
            <div id="network-status" class="output">Click "Check Network" to see status...</div>
        </div>

        <div class="section">
            <h2>Block Inspector</h2>
            <input type="number" id="blockNumber" placeholder="Block number (or leave empty for latest)" style="width: 200px;">
            <button class="btn" onclick="getBlock()">Get Block Details</button>
            <div id="block-output" class="output">Enter block number and click "Get Block Details"...</div>
        </div>

        <div class="section">
            <h2>Transaction Inspector</h2>
            <input type="text" id="txHash" placeholder="Transaction hash" style="width: 500px;">
            <button class="btn" onclick="getTransaction()">Get Transaction</button>
            <div id="tx-output" class="output">Enter transaction hash and click "Get Transaction"...</div>
        </div>

        <div class="section">
            <h2>Contract Inspector</h2>
            <select id="contractSelect">
                <option value="identity">ERC-8004 Identity Registry</option>
                <option value="reputation">Reputation Registry</option>
                <option value="validation">Validation Registry</option>
                <option value="hetu">HETU Token</option>
                <option value="flux">Intelligence Token (FLUX)</option>
                <option value="payment">Payment Token (USDC/AIUSD)</option>
                <option value="escrow">x402 Payment Escrow</option>
                <option value="subnet">Subnet Registry</option>
                <option value="verifier">PoCW Verifier</option>
            </select>
            <button class="btn" onclick="getContractInfo()">Get Contract Info</button>
            <div id="contract-output" class="output">Select contract and click "Get Contract Info"...</div>
        </div>

        <div class="section">
            <h2>üÜî ERC-8004 Identity Registry</h2>
            <button class="btn" onclick="getAgentIdentities()">View All Agent IDs</button>
            <input type="text" id="checkOwnerAddress" placeholder="Check agent IDs for address" style="width: 400px;">
            <button class="btn" onclick="checkAgentIDs()">Check Address</button>
            <div id="identity-output" class="output">Click "View All Agent IDs" to see registered agents...</div>
        </div>

        <div class="section">
            <h2>üîç ValidationRegistry - VLC Protocol Scores</h2>
            <p style="color: #888; margin: 10px 0;">Verify agent validation scores submitted to the ValidationRegistry</p>
            <input type="number" id="validationAgentId" placeholder="Agent ID (e.g., 0)" style="width: 150px;">
            <button class="btn" onclick="getValidationScores()">Check Validation Scores</button>
            <button class="btn" onclick="getAllValidations()">View All Validations</button>
            <div id="validation-output" class="output">Enter Agent ID to check validation scores...</div>
        </div>

        <div class="section">
            <h2>‚≠ê Reputation Registry</h2>
            <p style="color: #888; margin: 10px 0;">View agent reputation scores from user feedback</p>
            <input type="number" id="reputationAgentId" placeholder="Agent ID (e.g., 0)" style="width: 150px;">
            <button class="btn" onclick="getAgentReputation()">Check Agent Reputation</button>
            <button class="btn" onclick="getFeedbackTransactions()">View Feedback Transactions</button>
            <div id="reputation-output" class="output">Enter Agent ID to check reputation scores...</div>
        </div>

        <div class="section">
            <h2>Account Inspector</h2>
            <input type="text" id="accountAddress" placeholder="Enter address (miner, validator, etc.)" style="width: 400px;">
            <button class="btn" onclick="getAccountInfo()">Get Account Info</button>
            <div id="account-output" class="output">Enter address and click "Get Account Info"...</div>
        </div>

        <div class="section">
            <h2>Transaction Decoder</h2>
            <input type="text" id="decodeTxHash" placeholder="Transaction hash to decode" style="width: 500px;">
            <button class="btn" onclick="decodeTransaction()">Decode Transaction</button>
            <div id="decode-output" class="output">Enter transaction hash to decode contract calls...</div>
        </div>

        <div class="section">
            <h2>Recent Transactions</h2>
            <button class="btn" onclick="getRecentTransactions()">Get Last 10 Transactions</button>
            <div id="recent-tx-output" class="output">Click "Get Last 10 Transactions"...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/dist/ethers.umd.min.js"></script>
    <script>
        console.log("üîç PoCW Inspector loading...");
        
        let provider;
        let paymentTokenName = "USDC"; // Will be loaded from contract_addresses.json (USDC or AIUSD)
        let contractAddresses = {
            "IdentityRegistry": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
            "ValidationRegistry": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
            "ReputationRegistry": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
            "HETUToken": "0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9",
            "FLUXToken": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
            "PaymentToken": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
            "x402PaymentEscrow": "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6",
            "SubnetRegistry": "0x0165878A594ca255338adfa4d48449f69242Eb8F",
            "PoCWVerifier": "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853"
        };

        const contractABIsByType = {
            "IdentityRegistry": [
                "function balanceOf(address) view returns (uint256)",
                "function ownerOf(uint256) view returns (address)",
                "function name() view returns (string)",
                "function symbol() view returns (string)"
            ],
            "ValidationRegistry": [
                "function getValidationStatus(bytes32) view returns (address,uint256,uint8,bytes32,string,uint256,bool)",
                "function getAgentValidations(uint256) view returns (bytes32[])",
                "function getValidatorRequests(address) view returns (bytes32[])",
                "function getSummary(uint256,address[],string) view returns (uint64,uint8)",
                "function validationRequest(address,uint256,string,bytes32)",
                "function validationResponse(bytes32,uint8,string,bytes32,string)"
            ],
            "HETUToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)"
            ],
            "FLUXToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)"
            ],
            "PaymentToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)",
                "function decimals() view returns (uint8)"
            ],
            "x402PaymentEscrow": [
                "function getPayment(string) view returns (tuple(address,address,uint256,uint8,uint256,uint256))",
                "function coordinator() view returns (address)",
                "function paymentToken() view returns (address)"
            ],
            "PoCWVerifier": [
                "function getReputationScores(address) view returns (uint256, uint256)",
                "function calculateReputationScore(address) view returns (uint256)",
                "function calculateValidatorReputationScore(address) view returns (uint256)",
                "function minerIds(address) view returns (address, uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool, bytes32)",
                "function getValidatorStats(address) view returns (tuple(uint256,uint256,uint256,uint256,bool,uint256,uint256,uint256))",
                "function getValidatorConfidenceScore(address) view returns (uint256)",
                "function getEpochSubmission(bytes32, uint256) view returns (tuple(uint256,bytes,address[],uint256,bool,bool,uint256))",
                "function getSubnet(bytes32) view returns (tuple(address[],uint256,bool,uint256,uint256))",
                "function verifyAndDistributeRewards(bytes32, uint256, bool) returns (bool)",
                "function submitAndDistributeEpoch(string memory subnetId, bytes memory vlcGraphData, address[] memory successfulMiners, uint256 successfulTasks, uint256 failedTasks) external"
            ],
            "ReputationRegistry": [
                "function getSummary(uint256,address[],string,string) view returns (uint64,uint8)",
                "function readFeedback(uint256,uint64) view returns (address,uint8,string,string,string,bool)",
                "function feedbackIndexes(uint256,address) view returns (uint64)",
                "function giveFeedback(uint256 agentId, uint8 score, string tag1, string tag2, string endpoint, string feedbackURI, bytes32 feedbackHash)",
                "event NewFeedback(uint256 indexed agentId, address indexed feedbackProvider, uint64 feedbackIndex, uint8 score, string indexedTag1, string tag1, string tag2, string endpoint, string feedbackURI, bytes32 feedbackHash)"
            ]
        };

        let contractABIs = {};

        function updateContractABIs() {
            contractABIs = {};
            for (const [type, address] of Object.entries(contractAddresses)) {
                if (contractABIsByType[type]) {
                    contractABIs[address] = contractABIsByType[type];
                }
            }
        }

        async function loadContractAddresses() {
            try {
                console.log("üîÑ Loading contract addresses...");
                const response = await fetch('./contract_addresses.json');
                if (response.ok) {
                    const addresses = await response.json();
                    console.log("üìÑ Loaded addresses:", addresses);

                    // Load from new format where keys are contract names
                    if (addresses.PaymentToken) {
                        contractAddresses.PaymentToken = addresses.PaymentToken;
                        paymentTokenName = addresses.PaymentTokenName || "USDC";
                        contractAddresses.x402PaymentEscrow = addresses.x402PaymentEscrow;
                        contractAddresses.IdentityRegistry = addresses.IdentityRegistry || contractAddresses.IdentityRegistry;
                        contractAddresses.ValidationRegistry = addresses.ValidationRegistry || contractAddresses.ValidationRegistry;
                        contractAddresses.HETUToken = addresses.HETUToken || contractAddresses.HETUToken;
                        contractAddresses.FLUXToken = addresses.FLUXToken || contractAddresses.FLUXToken;
                        contractAddresses.SubnetRegistry = addresses.SubnetRegistry || contractAddresses.SubnetRegistry;
                        contractAddresses.PoCWVerifier = addresses.PoCWVerifier || contractAddresses.PoCWVerifier;
                        contractAddresses.ReputationRegistry = addresses.ReputationRegistry || contractAddresses.ReputationRegistry;
                        console.log("‚úÖ Payment token loaded:", paymentTokenName);
                    } else {
                        // Fallback to old format (address -> name mapping)
                        for (const [address, name] of Object.entries(addresses)) {
                            if (name === "ERC-8004 Identity Registry") contractAddresses.IdentityRegistry = address;
                            else if (name === "HETU Token") contractAddresses.HETUToken = address;
                            else if (name === "Intelligence Token (FLUX)") contractAddresses.FLUXToken = address;
                            else if (name.includes("Subnet Registry")) contractAddresses.SubnetRegistry = address;
                            else if (name.includes("PoCW") && name.includes("Verifier")) contractAddresses.PoCWVerifier = address;
                        }
                    }
                    updateContractABIs();
                    console.log("‚úÖ Updated contract addresses:", contractAddresses);
                }
            } catch (error) {
                console.log("‚ö†Ô∏è Using fallback addresses:", error.message);
            }
            updateContractABIs();
        }

        function waitForEthers() {
            if (typeof ethers !== 'undefined') {
                console.log("‚úÖ Ethers loaded");
                initializeApp();
            } else {
                console.log("‚è≥ Waiting for ethers...");
                setTimeout(waitForEthers, 100);
            }
        }
        
        async function initializeApp() {
            console.log("üöÄ Initializing app...");
            try {
                provider = new ethers.JsonRpcProvider("http://localhost:8545");
                console.log("‚úÖ Provider created");
                await loadContractAddresses();
                console.log("‚úÖ App initialized successfully");
            } catch (error) {
                console.error("‚ùå Init error:", error);
            }
        }

        async function checkNetwork() {
            try {
                console.log("üîç Checking network...");
                document.getElementById('network-status').innerHTML = `<div class="highlight">üîç Checking network...</div>`;
                
                const network = await provider.getNetwork();
                const blockNumber = await provider.getBlockNumber();
                const balance = await provider.getBalance("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
                
                let networkName = network.name;
                if (network.chainId === 31337n || network.chainId === 1337n) {
                    networkName = "Anvil/Hardhat Local";
                }
                
                document.getElementById('network-status').innerHTML = `
                    <div class="success">‚úÖ Connected to ${networkName}</div>
                    <div><span class="highlight">Chain ID:</span> ${network.chainId}</div>
                    <div><span class="highlight">Latest Block:</span> ${blockNumber}</div>
                    <div><span class="highlight">Deployer Balance:</span> ${ethers.formatEther(balance)} ETH</div>
                    <div><span class="highlight">RPC URL:</span> http://localhost:8545</div>
                `;
            } catch (error) {
                console.error("‚ùå Network check failed:", error);
                document.getElementById('network-status').innerHTML = `
                    <div class="error">‚ùå Connection Failed: ${error.message}</div>
                    <div style="margin-top: 10px;">
                        <span class="highlight">Troubleshooting:</span><br>
                        ‚Ä¢ Make sure Anvil is running on http://localhost:8545<br>
                        ‚Ä¢ Check console for detailed error messages
                    </div>
                `;
            }
        }

        async function getLatestBlock() {
            try {
                const blockNumber = await provider.getBlockNumber();
                const block = await provider.getBlock(blockNumber);
                
                document.getElementById('network-status').innerHTML = `
                    <div class="success">üìÑ Latest Block Details</div>
                    <div><span class="highlight">Number:</span> ${block.number}</div>
                    <div><span class="highlight">Hash:</span> ${block.hash}</div>
                    <div><span class="highlight">Transactions:</span> ${block.transactions.length}</div>
                    <div><span class="highlight">Timestamp:</span> ${new Date(block.timestamp * 1000).toLocaleString()}</div>
                `;
            } catch (error) {
                document.getElementById('network-status').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getBlock() {
            try {
                const blockNumberInput = document.getElementById('blockNumber').value.trim();
                const blockNumber = blockNumberInput ? parseInt(blockNumberInput) : await provider.getBlockNumber();
                
                document.getElementById('block-output').innerHTML = '<div class="highlight">üîç Loading block...</div>';
                
                const block = await provider.getBlock(blockNumber);
                if (!block) {
                    document.getElementById('block-output').innerHTML = '<div class="error">‚ùå Block not found</div>';
                    return;
                }
                
                const output = `
                    <div class="success">üìÑ Block ${block.number} Details</div>
                    <div><span class="highlight">Hash:</span> ${block.hash}</div>
                    <div><span class="highlight">Parent Hash:</span> ${block.parentHash}</div>
                    <div><span class="highlight">Timestamp:</span> ${new Date(block.timestamp * 1000).toLocaleString()}</div>
                    <div><span class="highlight">Gas Used:</span> ${block.gasUsed.toString()}</div>
                    <div><span class="highlight">Gas Limit:</span> ${block.gasLimit.toString()}</div>
                    <div><span class="highlight">Transactions:</span> ${block.transactions.length}</div>
                    ${block.transactions.length > 0 ? `<div><span class="highlight">Transaction Hashes:</span><br>${block.transactions.map(tx => `<span class="tx-hash">${tx}</span>`).join('<br>')}</div>` : ''}
                `;
                
                document.getElementById('block-output').innerHTML = output;
            } catch (error) {
                document.getElementById('block-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getTransaction() {
            try {
                const txHash = document.getElementById('txHash').value.trim();
                if (!txHash) {
                    document.getElementById('tx-output').innerHTML = '<div class="error">‚ùå Please enter transaction hash</div>';
                    return;
                }
                
                document.getElementById('tx-output').innerHTML = '<div class="highlight">üîç Loading transaction...</div>';
                
                const tx = await provider.getTransaction(txHash);
                const receipt = await provider.getTransactionReceipt(txHash);
                
                if (!tx) {
                    document.getElementById('tx-output').innerHTML = '<div class="error">‚ùå Transaction not found</div>';
                    return;
                }
                
                const output = `
                    <div class="success">üìÑ Transaction Details</div>
                    <div><span class="highlight">Hash:</span> <span class="tx-hash">${tx.hash}</span></div>
                    <div><span class="highlight">From:</span> <span class="address">${tx.from}</span></div>
                    <div><span class="highlight">To:</span> <span class="address">${tx.to || 'Contract Creation'}</span></div>
                    <div><span class="highlight">Value:</span> ${ethers.formatEther(tx.value)} ETH</div>
                    <div><span class="highlight">Gas Price:</span> ${tx.gasPrice ? ethers.formatUnits(tx.gasPrice, "gwei") + " gwei" : 'N/A'}</div>
                    <div><span class="highlight">Gas Limit:</span> ${tx.gasLimit.toString()}</div>
                    <div><span class="highlight">Nonce:</span> ${tx.nonce}</div>
                    <div><span class="highlight">Block:</span> ${tx.blockNumber || 'Pending'}</div>
                    <div><span class="highlight">Status:</span> ${receipt ? (receipt.status === 1 ? '<span class="success">Success</span>' : '<span class="error">Failed</span>') : 'Pending'}</div>
                    ${receipt ? `<div><span class="highlight">Gas Used:</span> ${receipt.gasUsed.toString()}</div>` : ''}
                `;
                
                document.getElementById('tx-output').innerHTML = output;
            } catch (error) {
                document.getElementById('tx-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getContractInfo() {
            try {
                const selected = document.getElementById('contractSelect').value;

                // Map dropdown values to addresses
                const addressMap = {
                    'identity': contractAddresses.IdentityRegistry,
                    'reputation': contractAddresses.ReputationRegistry,
                    'validation': contractAddresses.ValidationRegistry,
                    'hetu': contractAddresses.HETUToken,
                    'flux': contractAddresses.FLUXToken,
                    'payment': contractAddresses.PaymentToken,
                    'escrow': contractAddresses.x402PaymentEscrow,
                    'subnet': contractAddresses.SubnetRegistry,
                    'verifier': contractAddresses.PoCWVerifier
                };

                const address = addressMap[selected];
                if (!address || address === '') {
                    document.getElementById('contract-output').innerHTML = `
                        <div class="error">‚ùå Contract address not found</div>
                        <div style="margin-top: 10px;">
                            <span class="highlight">Selected:</span> ${selected}<br>
                            <span class="highlight">Address value:</span> ${address || 'undefined'}<br>
                            <span class="highlight">Tip:</span> Make sure the deployment script has completed and contract_addresses.json is updated
                        </div>
                    `;
                    console.log('Contract addresses:', contractAddresses);
                    return;
                }

                document.getElementById('contract-output').innerHTML = '<div class="highlight">üîç Loading contract info...</div>';

                const code = await provider.getCode(address);
                const balance = await provider.getBalance(address);

                let output = `
                    <div class="success">üìÑ Contract: ${selected.toUpperCase()}</div>
                    <div><span class="highlight">Address:</span> <span class="address">${address}</span></div>
                    <div><span class="highlight">Balance:</span> ${ethers.formatEther(balance)} ETH</div>
                    <div><span class="highlight">Is Contract:</span> ${code !== '0x' ? '<span class="success">Yes</span>' : '<span class="error">No</span>'}</div>
                `;

                // Add contract-specific info if available
                const typeMap = {
                    'identity': 'IdentityRegistry',
                    'reputation': 'ReputationRegistry',
                    'validation': 'ValidationRegistry',
                    'hetu': 'HETUToken',
                    'flux': 'FLUXToken',
                    'payment': 'PaymentToken',
                    'escrow': 'x402PaymentEscrow',
                    'verifier': 'PoCWVerifier'
                };

                const contractType = typeMap[selected];
                if (contractType && contractABIsByType[contractType]) {
                    const contract = new ethers.Contract(address, contractABIsByType[contractType], provider);

                    try {
                        if (selected === 'identity' || selected === 'hetu' || selected === 'flux' || selected === 'payment') {
                            const name = await contract.name();
                            const symbol = await contract.symbol();
                            const totalSupply = await contract.totalSupply();
                            output += `
                                <div style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                                    <div><span class="highlight">Name:</span> ${name}</div>
                                    <div><span class="highlight">Symbol:</span> ${symbol}</div>
                                    <div><span class="highlight">Total Supply:</span> ${ethers.formatEther(totalSupply)}</div>
                                </div>
                            `;
                        } else if (selected === 'escrow') {
                            const coordinatorAddr = await contract.coordinator();
                            const paymentTokenAddr = await contract.paymentToken();
                            output += `
                                <div style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                                    <div><span class="highlight">Coordinator:</span> <span class="address">${coordinatorAddr}</span></div>
                                    <div><span class="highlight">Payment Token (${paymentTokenName}):</span> <span class="address">${paymentTokenAddr}</span></div>
                                </div>
                            `;
                        }
                    } catch (e) {
                        console.log("Could not get contract details:", e.message);
                    }
                }

                document.getElementById('contract-output').innerHTML = output;
            } catch (error) {
                document.getElementById('contract-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getAccountInfo() {
            try {
                const address = document.getElementById('accountAddress').value.trim();
                if (!address) {
                    document.getElementById('account-output').innerHTML = '<div class="error">‚ùå Please enter an address</div>';
                    return;
                }

                document.getElementById('account-output').innerHTML = '<div class="highlight">üîç Loading account...</div>';

                const ethBalance = await provider.getBalance(address);
                const transactionCount = await provider.getTransactionCount(address);
                const code = await provider.getCode(address);
                const isContract = code !== '0x';

                let output = `
                    <div class="success">üë§ Account: ${address}</div>
                    <div><span class="highlight">ETH Balance:</span> ${ethers.formatEther(ethBalance)} ETH</div>
                    <div><span class="highlight">Nonce:</span> ${transactionCount}</div>
                    <div><span class="highlight">Type:</span> ${isContract ? '<span class="highlight">Contract</span>' : 'EOA (Externally Owned Account)'}</div>
                `;

                // Known address roles
                const knownAddresses = {
                    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266": "üîß Deployer", 
                    "0x70997970C51812dc3A010C7d01b50e0d17dc79C8": "‚úÖ Validator 1", 
                    "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC": "‚úÖ Validator 2",
                    "0x90F79bf6EB2c4f870365E785982E1f101E93b906": "‚úÖ Validator 3",
                    "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65": "‚úÖ Validator 4",
                    "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc": "‚õèÔ∏è Miner 1"
                };

                if (knownAddresses[address]) {
                    output += `<div style="margin-top: 10px;"><span class="highlight">Role:</span> ${knownAddresses[address]}</div>`;
                }

                // Try to get token balances
                try {
                    const hetuAddr = contractAddresses.HETUToken;
                    const hetuInterface = new ethers.Interface(contractABIs[hetuAddr]);
                    const hetuContract = new ethers.Contract(hetuAddr, hetuInterface, provider);
                    const hetuBalance = await hetuContract.balanceOf(address);

                    const fluxAddr = contractAddresses.FLUXToken;
                    const fluxInterface = new ethers.Interface(contractABIs[fluxAddr]);
                    const fluxContract = new ethers.Contract(fluxAddr, fluxInterface, provider);
                    const fluxBalance = await fluxContract.balanceOf(address);

                    output += `
                        <div style="margin-top: 15px;"><span class="highlight">Token Balances:</span></div>
                        <div style="margin-left: 20px;"><span class="highlight">HETU:</span> ${ethers.formatEther(hetuBalance)} HETU</div>
                        <div style="margin-left: 20px;"><span class="highlight">FLUX:</span> ${ethers.formatEther(fluxBalance)} FLUX</div>
                    `;

                    // Add Payment Token balance if contract is loaded
                    if (contractAddresses.PaymentToken && contractAddresses.PaymentToken !== '') {
                        try {
                            const paymentTokenAddr = contractAddresses.PaymentToken;
                            const paymentTokenInterface = new ethers.Interface(contractABIs[paymentTokenAddr]);
                            const paymentTokenContract = new ethers.Contract(paymentTokenAddr, paymentTokenInterface, provider);
                            const paymentBalance = await paymentTokenContract.balanceOf(address);
                            // USDC has 6 decimals, not 18
                            const formattedBalance = ethers.formatUnits(paymentBalance, 6);
                            output += `<div style="margin-left: 20px;"><span class="highlight">${paymentTokenName}:</span> ${formattedBalance} ${paymentTokenName}</div>`;
                        } catch (paymentError) {
                            console.log("‚ö†Ô∏è Could not get payment token balance:", paymentError.message);
                        }
                    }

                    // Get reputation scores from PoCW contract
                    try {
                        const pocwAddr = contractAddresses.PoCWVerifier;
                        const pocwInterface = new ethers.Interface(contractABIs[pocwAddr]);
                        const pocwContract = new ethers.Contract(pocwAddr, pocwInterface, provider);
                        
                        let minerRep = 0, validatorRep = 0;
                        
                        try {
                            const result = await pocwContract.getReputationScores(address);
                            minerRep = result[0];
                            validatorRep = result[1];
                        } catch (repError) {
                            try {
                                minerRep = await pocwContract.calculateReputationScore(address);
                            } catch (e) { minerRep = 0; }
                            try {
                                validatorRep = await pocwContract.calculateValidatorReputationScore(address);
                            } catch (e) { validatorRep = 0; }
                        }
                        
                        if (Number(minerRep) > 0 && Number(validatorRep) > 0) {
                            output += `
                                <div style="margin-top: 15px;"><span class="highlight">Reputation Scores:</span></div>
                                <div style="margin-left: 20px;"><span class="highlight">Miner Reputation:</span> ${minerRep.toString()} points</div>
                                <div style="margin-left: 20px;"><span class="highlight">Validator Reputation:</span> ${validatorRep.toString()} points</div>
                            `;
                        } else if (Number(minerRep) > 0) {
                            output += `<div style="margin-top: 15px;"><span class="highlight">Miner Reputation:</span> ${minerRep.toString()} points</div>`;
                        } else if (Number(validatorRep) > 0) {
                            output += `<div style="margin-top: 15px;"><span class="highlight">Validator Reputation:</span> ${validatorRep.toString()} points</div>`;
                        }
                    } catch (repError) {
                        console.log("‚ö†Ô∏è Could not get reputation scores:", repError.message);
                    }
                } catch (tokenError) {
                    console.log("‚ö†Ô∏è Could not get token balances:", tokenError.message);
                }

                document.getElementById('account-output').innerHTML = output;
            } catch (error) {
                document.getElementById('account-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getRecentTransactions() {
            try {
                document.getElementById('recent-tx-output').innerHTML = '<div class="highlight">üîç Loading transactions...</div>';
                
                const latestBlock = await provider.getBlockNumber();
                const transactions = [];
                
                for (let i = Math.max(0, latestBlock - 10); i <= latestBlock; i++) {
                    const block = await provider.getBlock(i);
                    if (block && block.transactions.length > 0) {
                        for (const txHash of block.transactions) {
                            const tx = await provider.getTransaction(txHash);
                            transactions.push({...tx, blockNumber: i});
                        }
                    }
                }
                
                const output = transactions.length > 0 ? `
                    <div class="success">üìÑ Recent Transactions (${transactions.length})</div>
                    ${transactions.slice(-10).reverse().map(tx => `
                        <div style="margin: 10px 0; padding: 10px; border: 1px solid #333; background: #111;">
                            <div><span class="highlight">Block ${tx.blockNumber}:</span> <span class="tx-hash">${tx.hash}</span></div>
                            <div><span class="highlight">From:</span> <span class="address">${tx.from}</span></div>
                            <div><span class="highlight">To:</span> <span class="address">${tx.to || 'Contract Creation'}</span></div>
                            <div><span class="highlight">Value:</span> ${ethers.formatEther(tx.value)} ETH</div>
                        </div>
                    `).join('')}
                ` : '<div class="error">No recent transactions found</div>';
                
                document.getElementById('recent-tx-output').innerHTML = output;
            } catch (error) {
                document.getElementById('recent-tx-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function decodeTransaction() {
            try {
                const txHash = document.getElementById('decodeTxHash').value.trim();
                if (!txHash) {
                    document.getElementById('decode-output').innerHTML = '<div class="error">‚ùå Please enter transaction hash</div>';
                    return;
                }
                
                console.log("üîç Decoding transaction:", txHash);
                document.getElementById('decode-output').innerHTML = '<div class="highlight">üîç Loading transaction...</div>';
                
                const tx = await provider.getTransaction(txHash);
                const receipt = await provider.getTransactionReceipt(txHash);
                
                if (!tx) {
                    document.getElementById('decode-output').innerHTML = '<div class="error">‚ùå Transaction not found</div>';
                    return;
                }
                
                let output = `
                    <div class="success">üîç Transaction Decoder</div>
                    <div><span class="highlight">Hash:</span> <span class="tx-hash">${tx.hash}</span></div>
                    <div><span class="highlight">To Contract:</span> <span class="address">${tx.to}</span></div>
                    <div><span class="highlight">Status:</span> ${receipt.status === 1 ? '<span class="success">Success</span>' : '<span class="error">Failed</span>'}</div>
                `;

                // Decode function call if we have the ABI
                console.log("üîç Transaction decoding debug:");
                console.log("  - tx.data:", tx.data);
                console.log("  - tx.to:", tx.to);
                console.log("  - Has tx.data:", !!(tx.data && tx.data !== '0x'));
                console.log("  - Has ABI for contract:", !!contractABIs[tx.to]);
                console.log("  - Available contractABIs keys:", Object.keys(contractABIs));
                
                if (tx.data && tx.data !== '0x') {
                    const functionSelector = tx.data.slice(0, 10);
                    console.log("  - Function selector:", functionSelector);
                    
                    if (contractABIs[tx.to]) {
                        console.log("  - ABI for contract:", contractABIs[tx.to]);
                        
                        try {
                            const contractInterface = new ethers.Interface(contractABIs[tx.to]);
                            console.log("  - Contract interface created successfully");
                            const decoded = contractInterface.parseTransaction({ data: tx.data, value: tx.value });
                            console.log("  - Transaction decoded successfully:", decoded);
                        
                            output += `
                                <div style="margin-top: 15px;"><span class="highlight">Function Call:</span></div>
                                <div style="margin-left: 20px;"><span class="highlight">Function:</span> ${decoded.name}</div>
                            `;
                        
                            if (decoded.args && decoded.args.length > 0) {
                                output += `<div style="margin-left: 20px;"><span class="highlight">Parameters:</span></div>`;
                                decoded.args.forEach((arg, idx) => {
                                    const param = decoded.fragment.inputs[idx];
                                    let value = arg.toString();
                                    
                                    // Format specific types
                                    if (param.type === 'uint256' && value.length > 10) {
                                        value = `${ethers.formatEther(arg)} (${value} wei)`;
                                    } else if (param.type === 'bytes32') {
                                        value = `${arg} (32-byte hash)`;
                                    } else if (param.type === 'bytes' && value.startsWith('0x')) {
                                        try {
                                            const decoded_bytes = ethers.toUtf8String(arg);
                                            if (decoded_bytes.includes('{') && decoded_bytes.includes('}')) {
                                                try {
                                                    const jsonData = JSON.parse(decoded_bytes);
                                                    value = `<div style="background: #0a0a0a; padding: 10px; margin: 5px 0; border: 1px solid #333;">
                                                        <div style="color: #ffff00;">üìä VLC Graph Data:</div>
                                                        <pre style="color: #00ff00; font-size: 11px; margin: 5px 0; white-space: pre-wrap;">${JSON.stringify(jsonData, null, 2)}</pre>
                                                    </div>`;
                                                } catch (jsonError) {
                                                    value = `Text data: "${decoded_bytes}"`;
                                                }
                                            } else {
                                                value = `Text: "${decoded_bytes.replace(/\0/g, '')}"`;
                                            }
                                        } catch (e) {
                                            value = `Binary data (${(value.length - 2) / 2} bytes): ${value.substring(0, 50)}${value.length > 50 ? '...' : ''}`;
                                        }
                                    } else if (param.type.includes('address')) {
                                        if (Array.isArray(arg)) {
                                            value = arg.map(addr => `<span class="address">${addr}</span>`).join(', ');
                                        } else {
                                            value = `<span class="address">${arg}</span>`;
                                        }
                                    } else if (param.type === 'string') {
                                        value = `"${arg}"`;
                                    } else if (param.type.includes('[]')) {
                                        if (Array.isArray(arg)) {
                                            value = `[${arg.join(', ')}] (${arg.length} items)`;
                                        } else {
                                            value = arg.toString();
                                        }
                                    } else if (param.type === 'bool') {
                                        value = arg ? '‚úÖ true' : '‚ùå false';
                                    }
                                    
                                    output += `<div style="margin-left: 40px;">${param.name} (${param.type}): ${value}</div>`;
                                });
                            }
                        } catch (e) {
                            console.log("‚ùå Failed to decode transaction:", e);
                            console.log("  - Error message:", e.message);
                            output += `<div style="margin-top: 10px;"><span class="error">Could not decode function call: ${e.message}</span></div>`;
                            output += `<div style="margin-top: 10px;"><span class="highlight">Raw Data:</span> ${tx.data}</div>`;
                        }
                    } else {
                        console.log("‚ö†Ô∏è Cannot decode transaction:");
                        if (!tx.data || tx.data === '0x') {
                            console.log("  - No transaction data");
                        } else if (!contractABIs[tx.to]) {
                            console.log("  - No ABI available for contract:", tx.to);
                        }
                    }
                    
                    if (tx.data && tx.data !== '0x') {
                        output += `<div style="margin-top: 10px;"><span class="highlight">Raw Input Data:</span><br><div style="word-break: break-all; font-size: 10px; background: #0a0a0a; padding: 10px;">${tx.data}</div></div>`;
                    }
                }

                // Decode events
                if (receipt.logs && receipt.logs.length > 0) {
                    output += `<div style="margin-top: 15px;"><span class="highlight">Events Emitted (${receipt.logs.length}):</span></div>`;
                    
                    receipt.logs.forEach((log, idx) => {
                        if (contractABIs[log.address]) {
                            try {
                                const contractInterface = new ethers.Interface(contractABIs[log.address]);
                                const parsedLog = contractInterface.parseLog(log);
                                
                                output += `
                                    <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                        <div><span class="highlight">Event:</span> ${parsedLog.name}</div>
                                        <div><span class="highlight">Contract:</span> <span class="address">${log.address}</span></div>
                                `;
                                
                                if (parsedLog.args && parsedLog.args.length > 0) {
                                    parsedLog.args.forEach((arg, argIdx) => {
                                        const input = parsedLog.fragment.inputs[argIdx];
                                        let value = arg.toString();
                                        
                                        if (input.type === 'uint256' && value.length > 10) {
                                            value = `${ethers.formatEther(arg)} tokens`;
                                        } else if (input.type.includes('address')) {
                                            value = `<span class="address">${arg}</span>`;
                                        }
                                        
                                        output += `<div style="margin-left: 20px;">${input.name}: ${value}</div>`;
                                    });
                                }
                                output += `</div>`;
                            } catch (e) {
                                output += `
                                    <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                        <div>Event ${idx}: <span class="address">${log.address}</span></div>
                                        <div>Topics: ${log.topics.length}</div>
                                    </div>
                                `;
                            }
                        } else {
                            output += `
                                <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                    <div>Event ${idx}: <span class="address">${log.address}</span></div>
                                    <div>Topics: ${log.topics.length}</div>
                                </div>
                            `;
                        }
                    });
                }

                document.getElementById('decode-output').innerHTML = output;
            } catch (error) {
                console.error("‚ùå Decode error:", error);
                document.getElementById('decode-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // ERC-8004 Identity Registry Functions
        async function getAgentIdentities() {
            try {
                document.getElementById('identity-output').innerHTML = `<div class="highlight">üîç Loading agent identities...</div>`;

                const identityAddress = contractAddresses.IdentityRegistry;
                const identityABI = contractABIsByType.IdentityRegistry;
                const identity = new ethers.Contract(identityAddress, identityABI, provider);

                let output = `
                    <div><span class="highlight">Identity Registry:</span> <span class="address">${identityAddress}</span></div>
                    <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
                        <div class="highlight">üìã Registered Agents:</div>
                `;

                // Try to get all agent IDs (assuming they start from 0)
                const knownAddresses = [
                    {name: "Deployer", addr: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"},
                    {name: "Validator-1", addr: "0x70997970C51812dc3A010C7d01b50e0d17dc79C8"},
                    {name: "Validator-2", addr: "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC"},
                    {name: "Validator-3", addr: "0x90F79bf6EB2c4f870365E785982E1f101E93b906"},
                    {name: "Validator-4", addr: "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65"},
                    {name: "Miner", addr: "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc"}
                ];

                // Check all known addresses for agent IDs
                for (const {name, addr} of knownAddresses) {
                    try {
                        const balance = await identity.balanceOf(addr);
                        if (balance > 0n) {
                            output += `<div style="margin: 10px 0; padding: 10px; background: #111; border-left: 3px solid #00ff00;">`;
                            output += `<div><span class="success">üë§ ${name}</span></div>`;
                            output += `<div><span class="highlight">Address:</span> <span class="address">${addr}</span></div>`;
                            output += `<div><span class="highlight">Agent IDs owned:</span> ${balance.toString()}</div>`;

                            // Get all agent IDs for this owner by checking sequential IDs (0-99)
                            // IdentityRegistry doesn't have totalSupply, so we check a reasonable range
                            const ownedTokens = [];
                            for (let tokenId = 0; tokenId < 100; tokenId++) {
                                try {
                                    const owner = await identity.ownerOf(tokenId);
                                    if (owner.toLowerCase() === addr.toLowerCase()) {
                                        ownedTokens.push(tokenId);
                                        output += `<div style="margin-left: 20px;"><span class="highlight">Agent ID:</span> ${tokenId}</div>`;
                                    }
                                } catch {
                                    // Token doesn't exist, continue checking
                                }
                            }
                            output += `</div>`;
                        }
                    } catch {}
                }

                output += `</div>`;
                document.getElementById('identity-output').innerHTML = output;

            } catch (error) {
                console.error("‚ùå Identity load error:", error);
                document.getElementById('identity-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function checkAgentIDs() {
            try {
                const address = document.getElementById('checkOwnerAddress').value.trim();
                if (!address) {
                    document.getElementById('identity-output').innerHTML = `<div class="error">‚ùå Please enter an address</div>`;
                    return;
                }

                document.getElementById('identity-output').innerHTML = `<div class="highlight">üîç Checking agent IDs for ${address}...</div>`;

                const identityAddress = contractAddresses.IdentityRegistry;
                const identityABI = contractABIsByType.IdentityRegistry;
                const identity = new ethers.Contract(identityAddress, identityABI, provider);

                const balance = await identity.balanceOf(address);

                let output = `
                    <div><span class="highlight">Address:</span> <span class="address">${address}</span></div>
                    <div><span class="highlight">Agent IDs owned:</span> ${balance.toString()}</div>
                `;

                if (balance > 0n) {
                    output += `<div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">`;
                    output += `<div class="highlight">Agent IDs:</div>`;

                    // Get all agent IDs by checking sequential IDs (0-99)
                    // IdentityRegistry doesn't have totalSupply, so we check a reasonable range
                    let foundTokens = 0;
                    for (let tokenId = 0; tokenId < 100; tokenId++) {
                        try {
                            const owner = await identity.ownerOf(tokenId);
                            if (owner.toLowerCase() === address.toLowerCase()) {
                                output += `
                                    <div style="margin: 5px 0; padding: 8px; background: #111;">
                                        <span class="highlight">Agent ID:</span> <span class="success">${tokenId}</span>
                                    </div>
                                `;
                                foundTokens++;
                            }
                        } catch (error) {
                            // Token doesn't exist, continue checking
                        }
                    }
                    output += `</div>`;
                } else {
                    output += `<div class="error" style="margin-top: 10px;">‚ùå No agent IDs found for this address</div>`;
                }

                document.getElementById('identity-output').innerHTML = output;

            } catch (error) {
                console.error("‚ùå Check error:", error);
                document.getElementById('identity-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // Reputation Registry Functions
        async function getAgentReputation() {
            try {
                const agentIdInput = document.getElementById('reputationAgentId').value.trim();
                if (!agentIdInput) {
                    document.getElementById('reputation-output').innerHTML = `<div class="error">‚ùå Please enter an agent ID</div>`;
                    return;
                }

                const agentId = parseInt(agentIdInput);
                document.getElementById('reputation-output').innerHTML = `<div class="highlight">üîç Loading reputation for Agent ID ${agentId}...</div>`;

                const reputationAddress = contractAddresses.ReputationRegistry;
                const reputationABI = contractABIsByType.ReputationRegistry;
                const reputation = new ethers.Contract(reputationAddress, reputationABI, provider);

                // Get agent reputation using getSummary
                // Parameters: agentId, clientAddresses (empty array), tag1, tag2 (ERC-8004 v1.0 uses strings)
                const [feedbackCount, avgScore] = await reputation.getSummary(
                    agentId,
                    [], // empty array for all clients
                    "", // tag1 = empty string (all tags)
                    ""  // tag2 = empty string (all tags)
                );

                let output = `
                    <div><span class="highlight">Reputation Registry:</span> <span class="address">${reputationAddress}</span></div>
                    <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
                        <div class="highlight">üìä Agent ID ${agentId} Reputation:</div>
                `;

                if (feedbackCount > 0n) {
                    const scorePercentage = (Number(avgScore) / 100 * 100).toFixed(1);

                    output += `
                        <div style="margin: 10px 0; padding: 10px; background: #111;">
                            <div><span class="highlight">Total Feedback Count:</span> ${feedbackCount.toString()}</div>
                            <div><span class="highlight">Average Score:</span> <span class="success">${avgScore.toString()}/100 (${scorePercentage}%)</span></div>
                        </div>
                    `;

                    // Visual score indicator
                    const barColor = avgScore >= 70 ? '#0f0' : avgScore >= 50 ? '#ff0' : '#f00';
                    output += `
                        <div style="margin: 10px 0;">
                            <div class="highlight">Score Visualization:</div>
                            <div style="width: 100%; height: 20px; background: #333; border: 1px solid #555; margin-top: 5px;">
                                <div style="width: ${scorePercentage}%; height: 100%; background: ${barColor};"></div>
                            </div>
                        </div>
                    `;
                } else {
                    output += `
                        <div class="error" style="margin: 10px 0;">
                            ‚ùå No reputation feedback found for Agent ID ${agentId}
                        </div>
                    `;
                }

                output += `</div>`;
                document.getElementById('reputation-output').innerHTML = output;

            } catch (error) {
                console.error("‚ùå Reputation check error:", error);
                document.getElementById('reputation-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // Get Feedback Transactions from ReputationRegistry events
        async function getFeedbackTransactions() {
            try {
                const agentIdInput = document.getElementById('reputationAgentId').value.trim();
                if (!agentIdInput) {
                    document.getElementById('reputation-output').innerHTML = `<div class="error">‚ùå Please enter an agent ID</div>`;
                    return;
                }

                const agentId = parseInt(agentIdInput);
                document.getElementById('reputation-output').innerHTML = `<div class="highlight">üîç Loading feedback transactions for Agent ID ${agentId}...</div>`;

                const reputationAddress = contractAddresses.ReputationRegistry;
                const reputationABI = contractABIsByType.ReputationRegistry;
                const reputation = new ethers.Contract(reputationAddress, reputationABI, provider);

                // Get feedback count first
                const [feedbackCount, avgScore] = await reputation.getSummary(agentId, [], "", "");

                let output = `
                    <div class="success">üìù Feedback Transactions for Agent #${agentId}</div>
                    <div><span class="highlight">Reputation Registry:</span> <span class="address">${reputationAddress}</span></div>
                    <div><span class="highlight">Total Feedbacks:</span> ${feedbackCount.toString()}</div>
                    <div><span class="highlight">Average Score:</span> ${avgScore.toString()}/100</div>
                    <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
                `;

                if (feedbackCount > 0n) {
                    // Query NewFeedback events for this agent
                    const filter = reputation.filters.NewFeedback(agentId);
                    const events = await reputation.queryFilter(filter, 0, 'latest');

                    output += `<div class="highlight">üìã Individual Feedback Submissions:</div>`;

                    for (const event of events) {
                        const tx = await event.getTransaction();
                        const block = await event.getBlock();
                        const timestamp = new Date(block.timestamp * 1000).toLocaleString();

                        // Parse event args
                        const feedbackIndex = event.args[2];
                        const score = event.args[3];
                        const tag1 = event.args[5] || '';
                        const tag2 = event.args[6] || '';
                        const endpoint = event.args[7] || '';
                        const feedbackURI = event.args[8] || '';

                        output += `
                            <div style="margin: 10px 0; padding: 12px; border: 1px solid #333; background: #111; border-left: 3px solid ${score >= 70 ? '#4CAF50' : score >= 50 ? '#ffff00' : '#ff4444'};">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span class="highlight">Feedback #${feedbackIndex.toString()}</span>
                                    <span style="color: ${score >= 70 ? '#4CAF50' : score >= 50 ? '#ffff00' : '#ff4444'}; font-size: 18px;">
                                        Score: ${score}/100
                                    </span>
                                </div>
                                <div><span class="highlight">Transaction:</span> <span class="tx-hash">${tx.hash}</span></div>
                                <div><span class="highlight">Block:</span> ${event.blockNumber}</div>
                                <div><span class="highlight">Time:</span> ${timestamp}</div>
                                <div><span class="highlight">Task ID:</span> ${feedbackURI || 'N/A'}</div>
                                <div><span class="highlight">Endpoint:</span> ${endpoint || 'N/A'}</div>
                                <div><span class="highlight">Tags:</span> ${tag1 || 'N/A'} / ${tag2 || 'N/A'}</div>
                                <div style="margin-top: 8px;">
                                    <button class="btn" style="padding: 4px 8px; font-size: 11px;" onclick="document.getElementById('decodeTxHash').value='${tx.hash}'; decodeTransaction();">
                                        Decode TX
                                    </button>
                                    <button class="btn" style="padding: 4px 8px; font-size: 11px;" onclick="document.getElementById('txHash').value='${tx.hash}'; getTransaction();">
                                        View TX Details
                                    </button>
                                </div>
                            </div>
                        `;
                    }

                    if (events.length === 0) {
                        // Fallback: Read feedbacks directly if events not available
                        output += `<div style="color: #888;">No events found. Reading feedbacks directly...</div>`;

                        for (let i = 0; i < Number(feedbackCount); i++) {
                            try {
                                const [provider, score, tag1, tag2, endpoint, isRevoked] = await reputation.readFeedback(agentId, i);
                                output += `
                                    <div style="margin: 10px 0; padding: 12px; border: 1px solid #333; background: #111; border-left: 3px solid ${score >= 70 ? '#4CAF50' : '#ff4444'};">
                                        <div><span class="highlight">Feedback #${i}</span></div>
                                        <div><span class="highlight">Score:</span> <span style="color: ${score >= 70 ? '#4CAF50' : '#ff4444'};">${score}/100</span></div>
                                        <div><span class="highlight">Provider:</span> <span class="address">${provider}</span></div>
                                        <div><span class="highlight">Tags:</span> ${tag1} / ${tag2}</div>
                                        <div><span class="highlight">Endpoint:</span> ${endpoint}</div>
                                        <div><span class="highlight">Revoked:</span> ${isRevoked ? '‚ùå Yes' : '‚úÖ No'}</div>
                                    </div>
                                `;
                            } catch (err) {
                                console.log(`Error reading feedback ${i}:`, err);
                            }
                        }
                    }
                } else {
                    output += `<div class="error">‚ùå No feedback found for Agent ID ${agentId}</div>`;
                }

                output += `</div>`;
                document.getElementById('reputation-output').innerHTML = output;

            } catch (error) {
                console.error("‚ùå Feedback transactions error:", error);
                document.getElementById('reputation-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // ValidationRegistry Functions for VLC Protocol Score Verification
        async function getValidationScores() {
            try {
                const agentId = document.getElementById('validationAgentId').value;
                if (!agentId && agentId !== 0) {
                    document.getElementById('validation-output').innerHTML = '<div class="error">‚ùå Please enter an Agent ID</div>';
                    return;
                }

                document.getElementById('validation-output').innerHTML = `<div class="highlight">üîç Loading validation scores for Agent #${agentId}...</div>`;

                // Get ValidationRegistry address from loaded config or use default
                const validationAddress = contractAddresses.ValidationRegistry || "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512";
                const validationABI = contractABIsByType.ValidationRegistry;
                const validationRegistry = new ethers.Contract(validationAddress, validationABI, provider);

                // Get all validations for this agent
                const requestHashes = await validationRegistry.getAgentValidations(agentId);

                if (requestHashes.length === 0) {
                    document.getElementById('validation-output').innerHTML = `
                        <div class="error">No validations found for Agent #${agentId}</div>
                    `;
                    return;
                }

                let output = `
                    <div class="success">üîç VLC Validation Scores for Agent #${agentId}</div>
                    <div><span class="highlight">ValidationRegistry:</span> <span class="address">${validationAddress}</span></div>
                    <div><span class="highlight">Total Validations:</span> ${requestHashes.length}</div>
                    <div><span class="highlight">Request Hashes:</span> ${requestHashes.map(h => h.slice(0,10) + '...').join(', ')}</div>
                    <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
                `;

                // Get details for each validation
                const scores = [];
                for (const hash of requestHashes) {
                    try {
                        // ERC-8004 v1.0: tag is string, hasResponse added
                        const result = await validationRegistry.getValidationStatus(hash);
                        console.log("Validation status result:", result);

                        // Handle both array and object return formats
                        const validatorAddress = result[0];
                        const agentIdReturned = result[1];
                        const score = result[2];
                        const responseHash = result[3];
                        const tag = result[4];
                        const timestamp = result[5];
                        const hasResponse = result[6];

                        console.log("Parsed values:", { validatorAddress, score, tag, hasResponse });

                        // Show debug info for each validation
                        output += `
                            <div style="margin: 5px 0; padding: 8px; background: #0a0a0a; border: 1px solid #333; font-size: 11px;">
                                <div><span class="highlight">Hash:</span> ${hash.slice(0,20)}...</div>
                                <div><span class="highlight">Validator:</span> ${validatorAddress}</div>
                                <div><span class="highlight">Score:</span> ${score} (type: ${typeof score})</div>
                                <div><span class="highlight">Tag:</span> "${tag}" (type: ${typeof tag})</div>
                                <div><span class="highlight">hasResponse:</span> ${hasResponse}</div>
                            </div>
                        `;

                        // Check if it's a VLC validation (v1.0: tag is string "VLC_PROTOCOL")
                        const isVLC = tag === "VLC_PROTOCOL" || (typeof tag === 'string' && tag.startsWith("VLC"));

                        // Only include if hasResponse is true (validator actually responded)
                        if (isVLC && hasResponse) {
                            scores.push({
                                validator: validatorAddress,
                                score: Number(score),
                                timestamp: Number(timestamp),
                                hash: hash,
                                tag: tag
                            });
                        }
                    } catch (err) {
                        console.log("Error fetching validation:", err);
                        output += `<div class="error">Error fetching ${hash.slice(0,10)}...: ${err.message}</div>`;
                    }
                }

                // Sort by timestamp
                scores.sort((a, b) => b.timestamp - a.timestamp);

                // Calculate average
                const avgScore = scores.length > 0 ?
                    Math.round(scores.reduce((sum, s) => sum + s.score, 0) / scores.length) : 0;

                output += `
                    <div style="margin-bottom: 15px;">
                        <span class="highlight">üìä Average VLC Score:</span>
                        <span style="font-size: 24px; color: ${avgScore >= 70 ? '#4CAF50' : '#ff4444'};">
                            ${avgScore}/100
                        </span>
                        <span style="color: ${avgScore >= 70 ? '#4CAF50' : '#ff4444'};">
                            (${avgScore >= 70 ? '‚úÖ PASSED' : '‚ùå FAILED'})
                        </span>
                    </div>
                `;

                // Display individual validator scores
                output += `<div class="highlight">Individual Validator Scores:</div>`;
                for (const score of scores) {
                    const date = new Date(score.timestamp * 1000).toLocaleString();

                    output += `
                        <div style="margin: 10px 0; padding: 10px; border: 1px solid #333; background: #111;">
                            <div><span class="highlight">Validator:</span> <span class="address">${score.validator}</span></div>
                            <div><span class="highlight">Score:</span>
                                <span style="color: ${score.score >= 70 ? '#4CAF50' : '#ff4444'};">
                                    ${score.score}/100
                                </span>
                            </div>
                            <div><span class="highlight">Time:</span> ${date}</div>
                            <div><span class="highlight">Request Hash:</span> <span class="tx-hash">${score.hash.slice(0, 10)}...</span></div>
                        </div>
                    `;
                }

                output += '</div>';
                document.getElementById('validation-output').innerHTML = output;

            } catch (error) {
                document.getElementById('validation-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getAllValidations() {
            try {
                document.getElementById('validation-output').innerHTML = `<div class="highlight">üîç Loading all validation records...</div>`;

                const validationAddress = contractAddresses.ValidationRegistry || "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512";
                const validators = [
                    "0x70997970C51812dc3A010C7d01b50e0d17dc79C8", // Validator 1
                    "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC", // Validator 2
                    "0x90F79bf6EB2c4f870365E785982E1f101E93b906", // Validator 3
                    "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65"  // Validator 4
                ];

                const validationABI = contractABIsByType.ValidationRegistry;
                const validationRegistry = new ethers.Contract(validationAddress, validationABI, provider);

                let allValidations = [];

                // Get validations from each validator
                for (let i = 0; i < validators.length; i++) {
                    const validator = validators[i];
                    try {
                        const requestHashes = await validationRegistry.getValidatorRequests(validator);

                        for (const hash of requestHashes) {
                            try {
                                // ERC-8004 v1.0: tag is string, hasResponse added
                                const [validatorAddr, agentId, score, responseHash, tag, timestamp, hasResponse] =
                                    await validationRegistry.getValidationStatus(hash);

                                // Check if it's a VLC validation (v1.0: tag is string)
                                const isVLC = tag === "VLC_PROTOCOL" || tag.startsWith("VLC");

                                // Only include if hasResponse is true
                                if (isVLC && hasResponse) {
                                    allValidations.push({
                                        validator: validatorAddr,
                                        validatorNum: i + 1,
                                        agentId: Number(agentId),
                                        score: Number(score),
                                        timestamp: Number(timestamp),
                                        hash: hash,
                                        tag: tag
                                    });
                                }
                            } catch (err) {
                                console.log("Error fetching validation details:", err);
                            }
                        }
                    } catch (err) {
                        console.log(`Error fetching requests for validator ${i+1}:`, err);
                    }
                }

                // Sort by timestamp (newest first)
                allValidations.sort((a, b) => b.timestamp - a.timestamp);

                // Group by agent
                const agentScores = {};
                for (const val of allValidations) {
                    if (!agentScores[val.agentId]) {
                        agentScores[val.agentId] = [];
                    }
                    agentScores[val.agentId].push(val);
                }

                let output = `
                    <div class="success">üìä All VLC Validation Records</div>
                    <div><span class="highlight">Total Validations:</span> ${allValidations.length}</div>
                    <div><span class="highlight">Unique Agents:</span> ${Object.keys(agentScores).length}</div>
                    <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
                `;

                // Display by agent
                for (const [agentId, validations] of Object.entries(agentScores)) {
                    const avgScore = Math.round(
                        validations.reduce((sum, v) => sum + v.score, 0) / validations.length
                    );

                    output += `
                        <div style="margin: 20px 0; padding: 15px; border: 2px solid #333; background: #0a0a0a;">
                            <div style="font-size: 18px; margin-bottom: 10px;">
                                <span class="highlight">Agent #${agentId}</span>
                                <span style="float: right; color: ${avgScore >= 70 ? '#4CAF50' : '#ff4444'};">
                                    Avg: ${avgScore}/100 (${avgScore >= 70 ? '‚úÖ PASSED' : '‚ùå FAILED'})
                                </span>
                            </div>
                    `;

                    for (const val of validations) {
                        const date = new Date(val.timestamp * 1000).toLocaleString();
                        output += `
                            <div style="margin: 5px 0; padding: 5px; border-left: 3px solid ${val.score >= 70 ? '#4CAF50' : '#ff4444'};">
                                Validator-${val.validatorNum}: ${val.score}/100 - ${date}
                            </div>
                        `;
                    }

                    output += '</div>';
                }

                output += '</div>';
                document.getElementById('validation-output').innerHTML = output;

            } catch (error) {
                document.getElementById('validation-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // Start waiting for ethers
        waitForEthers();
    </script>
</body>
</html>