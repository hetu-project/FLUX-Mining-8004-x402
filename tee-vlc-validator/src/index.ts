import express from 'express';
import { ethers } from 'ethers';
import * as dotenv from 'dotenv';

dotenv.config();

const app = express();
app.use(express.json());

// TEE Configuration
const RPC_URL = process.env.RPC_URL || 'https://eth-sepolia.g.alchemy.com/v2/your-key';
const VALIDATION_REGISTRY_ADDRESS = process.env.VALIDATION_REGISTRY_ADDRESS!;
const MNEMONIC = process.env.MNEMONIC!; // Auto-generated by EigenX KMS

// Initialize provider and wallet
const provider = new ethers.JsonRpcProvider(RPC_URL);
const wallet = ethers.Wallet.fromPhrase(MNEMONIC).connect(provider);

console.log('ğŸ” TEE VLC Validator Initializing...');
console.log(`   TEE Wallet: ${wallet.address}`);
console.log(`   Network: ${RPC_URL.includes('sepolia') ? 'Sepolia' : 'Mainnet'}`);

// ValidationRegistry ABI
const VALIDATION_ABI = [
  "function validationRequest(address validator, uint256 agentId, string description, bytes32 requestHash)",
  "function validationResponse(bytes32 requestHash, uint8 score, string feedback, bytes32 responseHash, bytes32 tag)"
];

const validationRegistry = new ethers.Contract(
  VALIDATION_REGISTRY_ADDRESS,
  VALIDATION_ABI,
  wallet
);

// VLC State Interface
interface VLCClock {
  [nodeId: string]: number;
}

interface VLCState {
  clock: VLCClock;
  events: string[];
}

// Agent response types (must match Go constants)
type OutputType = 'need_more_info' | 'output_ready';

interface AgentResponse {
  outputType: OutputType;
  output?: string;
  infoRequest?: string;
  vlcClock: VLCClock;
}

/**
 * Full VLC Protocol Validation Test
 * This implements the complete validator logic that was previously in Go
 * Now running in hardware-protected TEE environment
 */
async function validateAgentVLCProtocol(
  agentEndpoint: string,
  agentId: string
): Promise<{ valid: boolean; score: number; feedback: string; initialClock: VLCClock; afterFirstStep: VLCClock; afterSecondStep: VLCClock }> {

  // IMPORTANT: The agent uses node ID "1" for VLC clock tracking
  // The agentId is the NFT ID (e.g., 1168), but VLC uses node ID "1"
  const nodeId = "1";

  console.log(`\nğŸ” [TEE Validator] VLC Validation Test Starting`);
  console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
  console.log(`Agent Endpoint: ${agentEndpoint}`);
  console.log(`Agent ID: ${agentId}`);
  console.log(`VLC Node ID: ${nodeId}`);
  console.log();

  try {
    // STEP 1: Get initial VLC state from agent
    console.log(`ğŸ“Š Getting initial VLC state...`);
    const initialStateRes = await fetch(`${agentEndpoint}/vlc-state`);
    if (!initialStateRes.ok) {
      throw new Error(`Failed to get initial VLC state: ${initialStateRes.statusText}`);
    }
    const initialState: any = await initialStateRes.json();
    const initialClock: VLCClock = initialState.clock;
    console.log(`   Initial VLC State:`, initialClock);
    console.log();

    // STEP 2: Send intentionally ambiguous task to trigger NeedMoreInfo
    const ambiguousTask = "Calculate the optimal route";
    console.log(`ğŸ“¤ [Step 1] Sending ambiguous task: "${ambiguousTask}"`);

    const step1Res = await fetch(`${agentEndpoint}/process-task`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        task: ambiguousTask,
        nodeId: 1,
        requestId: 'vlc-validation-test-1'
      })
    });

    if (!step1Res.ok) {
      throw new Error(`Failed to process task: ${step1Res.statusText}`);
    }

    const response1 = await step1Res.json() as AgentResponse;

    // STEP 3: Verify first response requests more information
    console.log(`ğŸ“¥ Agent Response: ${response1.outputType}`);
    if (response1.outputType !== 'need_more_info') {
      return {
        valid: false,
        score: 0,
        feedback: `Expected need_more_info, got ${response1.outputType}`,
        initialClock,
        afterFirstStep: response1.vlcClock,
        afterSecondStep: response1.vlcClock
      };
    }
    console.log(`âœ… Correct: Agent requested additional information`);
    console.log(`   Info Request: "${response1.infoRequest}"`);

    // STEP 4: Verify VLC incremented correctly
    const afterFirstStep = response1.vlcClock;
    console.log(`ğŸ“Š VLC After Step 1 (need_more_info):`, afterFirstStep);

    const initialValue = initialClock[nodeId] || 0;
    const afterFirstValue = afterFirstStep[nodeId] || 0;
    const expectedIncrement = 2; // message enter + message leave

    if (afterFirstValue !== initialValue + expectedIncrement) {
      return {
        valid: false,
        score: 40,
        feedback: `VLC did not increment correctly on NeedMoreInfo response. Expected +${expectedIncrement}, got ${afterFirstValue - initialValue}`,
        initialClock,
        afterFirstStep,
        afterSecondStep: afterFirstStep
      };
    }
    console.log(`âœ… Correct: VLC incremented properly [node ${nodeId}: ${initialValue} â†’ ${afterFirstValue}]`);
    console.log();

    // STEP 5: Provide additional information
    const additionalInfo = "Route from point A(0,0) to point B(10,10), avoid obstacles at (5,5)";
    console.log(`ğŸ“¤ [Step 2] Providing additional info: "${additionalInfo}"`);

    const step2Res = await fetch(`${agentEndpoint}/process-additional-info`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        originalTask: ambiguousTask,
        additionalInfo,
        nodeId: 1,
        requestId: 'vlc-validation-test-1'
      })
    });

    if (!step2Res.ok) {
      throw new Error(`Failed to process additional info: ${step2Res.statusText}`);
    }

    const response2 = await step2Res.json() as AgentResponse;

    // STEP 6: Verify final response is ready
    console.log(`ğŸ“¥ Agent Response: ${response2.outputType}`);
    if (response2.outputType !== 'output_ready') {
      return {
        valid: false,
        score: 60,
        feedback: `Expected output_ready after additional info, got ${response2.outputType}`,
        initialClock,
        afterFirstStep,
        afterSecondStep: response2.vlcClock
      };
    }
    console.log(`âœ… Correct: Agent provided final output`);
    const outputPreview = response2.output ? response2.output.substring(0, 80) : '';
    console.log(`   Output: "${outputPreview}${response2.output && response2.output.length > 80 ? '...' : ''}"`);


    // STEP 7: Verify VLC incremented again
    const afterSecondStep = response2.vlcClock;
    console.log(`ğŸ“Š VLC After Step 2:`, afterSecondStep);

    const afterSecondValue = afterSecondStep[nodeId] || 0;
    if (afterSecondValue !== afterFirstValue + expectedIncrement) {
      return {
        valid: false,
        score: 70,
        feedback: `VLC did not increment correctly on second response. Expected +${expectedIncrement}, got ${afterSecondValue - afterFirstValue}`,
        initialClock,
        afterFirstStep,
        afterSecondStep
      };
    }
    console.log(`âœ… Correct: VLC incremented properly [node ${nodeId}: ${afterFirstValue} â†’ ${afterSecondValue}]`);
    console.log();

    // STEP 8: Verify overall causality
    console.log(`ğŸ” Verifying causal consistency...`);
    if (!verifyCausalConsistency(initialClock, afterFirstStep, afterSecondStep, nodeId)) {
      return {
        valid: false,
        score: 85,
        feedback: 'Causal consistency violated',
        initialClock,
        afterFirstStep,
        afterSecondStep
      };
    }
    console.log(`âœ… Causal consistency maintained throughout test`);
    console.log();

    // ALL TESTS PASSED
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    console.log(`âœ… VLC VALIDATION PASSED`);
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    console.log(`Agent ID: ${agentId}`);
    console.log(`Score: 100/100`);
    console.log(`Status: AUTHORIZED for subnet operations`);
    console.log(`VLC Implementation: CORRECT`);
    console.log();

    return {
      valid: true,
      score: 100,
      feedback: "VLC validation passed - agent correctly implements causal consistency",
      initialClock,
      afterFirstStep,
      afterSecondStep
    };

  } catch (error: any) {
    console.error(`âŒ Validation error:`, error.message);
    throw error;
  }
}

/**
 * Verify causal consistency across VLC states
 */
function verifyCausalConsistency(
  initial: VLCClock,
  step1: VLCClock,
  step2: VLCClock,
  agentId: string
): boolean {
  // Each step should be causally after the previous
  const initialValue = initial[agentId] || 0;
  const step1Value = step1[agentId] || 0;
  const step2Value = step2[agentId] || 0;

  if (step1Value <= initialValue) {
    return false;
  }
  if (step2Value <= step1Value) {
    return false;
  }

  return true;
}

/**
 * API Endpoint: Validate Agent VLC Protocol
 * Called by run-flux-mining.sh during agent registration
 * This performs the FULL validation test by interacting with the agent
 */
app.post('/validate-agent', async (req, res) => {
  try {
    const { agentId, agentEndpoint, requestHash } = req.body;

    console.log(`\n${'='.repeat(60)}`);
    console.log(`ğŸ“¥ Validation Request Received`);
    console.log(`   Agent ID: ${agentId}`);
    console.log(`   Agent Endpoint: ${agentEndpoint}`);
    console.log(`   Request Hash: ${requestHash}`);
    console.log(`${'='.repeat(60)}`);

    // Validate input
    if (!agentId || !agentEndpoint || !requestHash) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: agentId, agentEndpoint, requestHash'
      });
    }

    // Perform FULL VLC validation test in TEE
    const result = await validateAgentVLCProtocol(
      agentEndpoint,
      agentId.toString()
    );

    console.log(`\nâœ… Validation Complete`);
    console.log(`   Request Hash: ${requestHash}`);

    // Generate response hash for signature
    const responseData = `vlc-response-${agentId}-${wallet.address}-${result.score}`;
    const responseHash = ethers.keccak256(ethers.toUtf8Bytes(responseData));
    // VLC_TAG: RIGHT-padded (text at beginning, zeros at end) to match contract
    const vlcTagBytes = ethers.toUtf8Bytes("VLC_PROTOCOL");
    const vlcTag = ethers.hexlify(ethers.concat([vlcTagBytes, new Uint8Array(32 - vlcTagBytes.length)]));

    // Sign the validation result with TEE wallet
    const messageHash = ethers.solidityPackedKeccak256(
      ['bytes32', 'uint8', 'bytes32', 'bytes32'],
      [requestHash, result.score, responseHash, vlcTag]
    );
    const signature = await wallet.signMessage(ethers.getBytes(messageHash));

    console.log(`   ğŸ” TEE Signature: ${signature.substring(0, 20)}...`);
    console.log(`   Note: Validation complete - agent will record results on-chain`);

    // Return comprehensive result (TEE provides attestation, agent submits to blockchain)
    const teeResult = {
      success: true,
      agentId,
      validation: {
        valid: result.valid,
        score: result.score,
        feedback: result.feedback,
        requestHash: requestHash,
        validatorAddress: wallet.address,
        responseHash: responseHash,
        teeWallet: wallet.address,
        teeSignature: signature
      },
      vlcStates: {
        initial: result.initialClock,
        afterFirstStep: result.afterFirstStep,
        afterSecondStep: result.afterSecondStep
      },
      tee: {
        wallet: wallet.address,
        instanceId: process.env.INSTANCE_ID || 'local-dev',
        timestamp: Date.now(),
        attestation: "verified-by-eigencompute-tee"
      }
    };

    console.log(`\nâœ… Validation Complete`);
    console.log(`${'='.repeat(60)}\n`);

    res.json(teeResult);

  } catch (error: any) {
    console.error('\nâŒ Validation Error:', error.message);
    res.status(500).json({
      success: false,
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

/**
 * Health Check Endpoint
 */
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'tee-vlc-validator',
    teeWallet: wallet.address,
    network: RPC_URL.includes('sepolia') ? 'sepolia' : 'mainnet',
    instanceId: process.env.INSTANCE_ID || 'local-dev',
    timestamp: Date.now()
  });
});

/**
 * Get TEE Info
 */
app.get('/info', (req, res) => {
  res.json({
    service: 'TEE VLC Validator',
    version: '1.0.0',
    teeWallet: wallet.address,
    validationRegistry: VALIDATION_REGISTRY_ADDRESS,
    network: RPC_URL.includes('sepolia') ? 'Sepolia Testnet' : 'Ethereum Mainnet',
    capabilities: [
      'VLC clock increment validation',
      'Causal consistency verification',
      'On-chain validation submission',
      'Hardware-backed TEE execution'
    ]
  });
});

// Start server
const PORT = parseInt(process.env.APP_PORT || '3000');
app.listen(PORT, '0.0.0.0', () => {
  console.log(`\n${'='.repeat(60)}`);
  console.log(`ğŸš€ TEE VLC Validator Running`);
  console.log(`   Port: ${PORT}`);
  console.log(`   TEE Wallet: ${wallet.address}`);
  console.log(`   ValidationRegistry: ${VALIDATION_REGISTRY_ADDRESS}`);
  console.log(`   Health: http://0.0.0.0:${PORT}/health`);
  console.log(`   Info: http://0.0.0.0:${PORT}/info`);
  console.log(`${'='.repeat(60)}\n`);
});
